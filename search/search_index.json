{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Diving into pygeoapi workshop!","text":"<p>Version: 1.1</p> <p></p> <p>pygeoapi is a Python server implementation of the OGC API suite of standards. The project emerged as part of the next generation OGC API efforts in 2018 and provides the capability for organizations to deploy a RESTful OGC API endpoint using OpenAPI, GeoJSON, and HTML. pygeoapi is open source and released under an MIT license.</p> <p>Diving into pygeoapi is a half day workshop designed for users to become familiar with installing, configuring, publishing data to and extending pygeoapi. This workshop will cover publishing geospatial data to the Web using pygeoapi in support of the suite of OGC API standards.</p> <p>This workshop covers a wide range of topics (install/setup/configuration, publishing, cloud, templating, plugins, etc.). Please see the left hand navigation for the table of contents.</p>"},{"location":"#your-gise-hub-winter-school-on-ogc-stack-workshop-team","title":"Your GISE Hub Winter School on OGC Stack workshop team","text":"Joana Simoes (OGC) Tom Kralidis (OSGeo) Krishna Lodha (Rotten Grapes)"},{"location":"#about-this-tutorial","title":"About this tutorial","text":"<p>This tutorial is a combination of step-by-step explanations of various aspects of pygeoapi as well as a series of exercises to familiarize yourself with the project.</p> <p>Exercises are indicated as follows:</p> <p>Example exercise</p> <p>A section marked like this indicates that you can try out the exercise.</p> <p>Example exercise with tabs</p> <p>A section marked like this indicates that you can try out the exercise and choose your environment (Linux/Mac or Windows).</p> Linux/MacWindows <p> <pre><code>docker run -p 5000:80 -v $(pwd)/default.config.yml:/pygeoapi/local.config.yml geopython/pygeoapi:latest\n</code></pre> </p> <p> <pre><code>docker run -p 5000:80 -v ${pwd}/default.config.yml:/pygeoapi/local.config.yml geopython/pygeoapi:latest\n</code></pre> </p> <p>Also you will notice tips and notes sections within the text:</p> <p>Tip</p> <p>Tips share additional help on how to best achieve tasks</p> <p>Examples are indicated as follows:</p> <p>Code <pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;This is an HTML sample&lt;/title&gt;\n    &lt;/head&gt;\n&lt;/html&gt;\n</code></pre></p> <p>Configuration <pre><code>my-collection:\n    type: collection\n    title: my cool collection title\n    description: my cool collection description\n</code></pre></p> <p>Snippets which need to be typed in a on a terminal/console are indicated as:</p> <pre><code>echo 'Hello world'\n</code></pre>"},{"location":"#workshop-location-and-materials","title":"Workshop location and materials","text":"<p>This workshop is always provided live at https://dive.pygeoapi.io.</p> <p>The workshop contents, wiki and issue tracker are managed on GitHub at https://github.com/geopython/diving-into-pygeoapi.</p>"},{"location":"#support","title":"Support","text":"<p>A Gitter channel exists for discussion and live support from the developers of the workshop and other workshop participants.</p> <p>For issues/bugs/suggestions or improvements/contributions, use the GitHub issue tracker.</p> <p>All bugs, enhancements and issues can be reported on GitHub.</p> <p>As always, core pygeoapi support and community information can be found on the pygeoapi website.</p> <p>Contributions are always enncouraged and welcome!</p>"},{"location":"#now-on-to-the-workshop-lets-go","title":"Now, on to the workshop.  Let's go!","text":""},{"location":"conclusion/","title":"Conclusion","text":"<p>We hope this workshop provided a valuable overview of the many features of pygeoapi. The project's goal is enabling low barrier, simple and flexible data publishing, using the OGC API suite of standards.</p> <p></p> <p></p>"},{"location":"conclusion/#gise-hub-winter-school-on-ogc-stack","title":"GISE Hub Winter School on OGC Stack","text":"<p>Sending you all best wishes and enjoy the rest of the GISE Hub Winter School on OGC Stack!</p>"},{"location":"conclusion/#contributing","title":"Contributing","text":"<p>Suggestions, improvements and fixes are always welcome. Please visit our community page for more information on getting in touch.</p> <p>Thank you for your interest in pygeoapi!</p>"},{"location":"introduction/","title":"Introduction to pygeoapi","text":"<p>The development team of pygeoapi (yes, spelled in lowercase) is excited to welcome you in this workshop! </p> <p>In this half day workshop, we will give you an introduction to pygeoapi, how to publish data, and provide resources and tips for future reading and reference (i.e. where to go when you don't know!).</p> <p>Although pygeoapi is written in Python and can be customizable and extensible (plugins)  for Python developers, Python skills are not required to install, setup and publish your geospatial data as part of this workshop. All you need for the workshop is your favorite text editor and Docker (we will more information in the setup section).</p>"},{"location":"introduction/#background-reading","title":"Background reading","text":"<p>The pygeoapi website is the main entrypoint for both end-users and developers where you can find:</p> <ul> <li>official documentation</li> <li>the default and latest presentations</li> <li>documentation and presentations archive</li> <li>code on GitHub</li> <li>Docker images available on Docker Hub</li> <li>pygeoapi releases in the Python Package Index (PyPI)</li> </ul> <p>Given pygeoapi implements a number of OGC API standards, you may also want to read about these on ogcapi.ogc.org.</p>"},{"location":"introduction/#existing-deployments","title":"Existing Deployments","text":"<p>A number of organizations have deployed pygeoapi to their operations. To get a feel of how pygeoapi is used in practice, check out our up to date live deployments page. By default, the pygeoapi public demo at demo.pygeoapi.io is always maintained and made available by the development team. Check out the main instance which always runs the latest GitHub version.</p> <p>Interested in the demo site setup itself? demo.pygeoapi.io is developed in a GitHub repository using a DevOps continuous deployment (CD) workflow. Even more recent GitOps deployments were developed for Geonovum and the European Commission Joint Research Center.</p> <p>The above examples may help as starting points for your own pygeoapi setup and deployment, so feel free to study and use them!</p>"},{"location":"introduction/#history","title":"History","text":"<p>Starting in 2018, pygeoapi emerged as part of the initial efforts for the development of OGC API standards. OGC API code sprints were instrumental for agile development and pouring the foundation of the project.</p> <p>The core design principles are as follows:</p> <ul> <li>simplicity / low barrier to entry</li> <li>long term sustainability</li> <li>modularity</li> <li>extensibility</li> <li>building on a large ecosystem of Free Open Source and OSGeo components such as GDAL, rasterio, Shapely, Pandas, Elasticsearch, PostGIS and many others</li> </ul> <p>The project was initiated by Tom Kralidis. Within weeks, several talented developers joined the project, which led to the formation of a core team and Project Steering Committee (PSC). Contributions continued as well from additional developers and users who happily provided new functionality, bug fixes, and documentation updates. As a result, a healthy community quickly emerged with a common interest in open source, OGC API standards, low barrier, modular and extensible. The rest, as they say, is history.</p> <p>pygeoapi is an OSGeo Project and an OGC Reference Implementation.</p>"},{"location":"setup/","title":"Workshop environment setup","text":"<p>In this workshop we use the following materials:</p> <ol> <li>Documentation - (like this page): access latest on dive.pygeoapi.io</li> <li>Exercises - download the latest zip file, unzip, find exercises in <code>workshop/exercises</code> <sup>1</sup></li> <li>Docker - all examples/exercises are run in a <code>Docker container</code> in <code>workshop/exercises</code></li> </ol>"},{"location":"setup/#text-editor","title":"Text editor","text":"<p>Your text editor needs to be able to edit configuration files in plain text. Below are some choices for text editors (there may be others), along with what some of the pygeoapi developers prefer to use:</p> <ul> <li>Notepad or Notepad++ (Windows)</li> <li>Sublime Text: Angelos</li> <li>IntelliJ IDEA: Just</li> <li>Emacs: Just</li> <li>Visual Studio Code: Francesco, Angelos, Joana</li> <li><code>vi</code> / <code>vim</code>: Tom, Angelos</li> </ul> <p>Having said this, please feel free to use what works for you :)</p>"},{"location":"setup/#yaml","title":"YAML","text":"<p>Most exercises will focus on editing the pygeoapi configuration, which is in the YAML format. If you are not familiar with YAML, it is worth reading through a tutorial to become aware of YAML syntax and indentation.</p> <p>The main requirement for the training is to install Docker and/with Docker Compose on your system. We strongly advise to install Docker before the workshop starts.</p> <p>Although several custom installation scenarios are possible (see the documentation for more information), these are not considered in this workshop given the ability to install a fully reproducible environment via Docker and Docker Compose.</p> <p>Workshop Exercises will also be based on Docker, hence a custom installation would at least be 'challenging'. The good news is that only a single installation (Docker) is needed! The Docker images used in this workshop contain the latest pygeoapi and all its dependencies and external services (e.g. PostGIS).</p>"},{"location":"setup/#about-docker","title":"About Docker","text":"<p>Docker has been available for almost 10 years, and provided as a deployment option on numerous FOSS software and OSGeo projects. Given the current era of computing, chances are that you have heard of Docker and containerization. Or, perhaps are already familiar and hopefully using Docker already. If not, there is an abundance of introductory materials that can be found online like this tutorial from IBM.</p> <p>FOSS4G software has benefitted greatly from Docker (consistent packaging, isolation, integration and upgrade patterns) in comparison to custom installations. Though today we mainly use Docker, the bigger picture is the use of Containers as a next step in virtualization. Containerization certainly deserves its own workshop, so for the purpose of this workshop we only cover the basics of Docker and Docker Compose.</p> <p>Docker Compose is an addition to Docker to facilitate the orchestration (configuration) of one or more Docker 'Containers' (a Container is a running instance of a Docker image) using a configuration convention (the Docker Compose YAML file), usually named <code>docker-compose.yml</code>.</p> <p>Stepping up further are even more sophisticated Docker orchestrators like  Rancher and Kubernetes, but for this workshop, Docker and Docker Compose are all we need.</p>"},{"location":"setup/#installation","title":"Installation","text":"<p>Docker installation has greatly progressed over the years. This is the only part of the workshop which is dependent on the system/OS you are running (e.g. Windows, Mac or Linux). For each system the Docker website provides detailed installation instructions. Please follow these consistently.</p> <p>Docker compose variants</p> <p>Docker Compose in older (pre Compose v2) versions was a separate (Python) program to install, though it was usually present in Docker Desktop.  The <code>docker compose</code> command in that case is <code>docker-compose</code> (hyphened). Since 2021, Docker Desktop includes Compose in the Docker CLI. The command is then <code>docker compose</code> (space).</p> <p>In our texts we will use <code>docker-compose</code>. Depending on your installation you may need to replace the hyphen (<code>-</code>) with a space. But you can always install the original compose (<code>docker-compose</code>) via <code>pip3 install docker-compose</code>.</p> <p>For many platforms a product called <code>Docker Desktop</code> is available, which includes <code>Docker compose</code>:</p> <ul> <li>Windows installation</li> <li>Mac installation</li> <li>Linux installation</li> </ul> <p>Some notes:</p> <ul> <li>On Windows we recommend using the Windows Subsystem for Linux (WSL) as it also provides a powerful (Bash) command line and has optimal integration with Docker</li> <li>On Mac, if you are using Homebrew, consider (as the author has) using the brew Docker formula</li> <li>On MacOS Monterey, there is an issue with the port 5000 that is already used and therefore conflicting to the default one used by pygeoapi. If you are facing with this error <code>OSError: [Errno 48] Address already in use</code> then you need to can disable the Airplay Receiver from <code>System Preference-&gt;Sharing</code> of your MacOS (detailed description in this blog post).</li> <li>On Linux, you can choose the relevant installer for your platform. You can also use Virtualbox with a Ubuntu image or use a cloud VM</li> <li>Docker Desktop includes a graphical user interface with some interesting options. You can see logs and information about running containers, open their service in a browser or even open a terminal inside the container</li> </ul> <p>If all goes well, you should be able to run Docker from the command line as follows: <sup>2</sup></p> <pre><code>docker --version\nDocker version 20.10.17, build 100c701\n\ndocker-compose --version  \nDocker Compose version v2.6.1\n</code></pre> <p>(It is not required that your version numbers exactly match).</p>"},{"location":"setup/#quickstart","title":"Quickstart","text":"<p>Once Docker is available on your system, running the pygeoapi container with its built-in configuration and  data is a one-liner. </p> <p>First run via Docker</p> <p>Open a terminal session and run:</p> <p> <pre><code>docker run --rm -p 5000:80 geopython/pygeoapi:latest\nUnable to find image 'geopython/pygeoapi:latest' locally\nlatest: Pulling from geopython/pygeoapi\nd7bfe07ed847: Already exists \nd5d0144a7164: Already exists \nafe0923a0fa0: Already exists \n75f8618c4e86: Already exists \nc603397fd6ad: Already exists \n6584a95328b3: Already exists \nfd93e44631d9: Already exists \n6a3201071a5d: Already exists \n4f4fb700ef54: Already exists \nDigest: sha256:27b2b219497a6ea382a946ee90ae96ad00b5c1d8e9b725fccf23211978fef124\nStatus: Downloaded newer image for geopython/pygeoapi:latest\nSTART /entrypoint.sh\nTrying to generate openapi.yml\nopenapi.yml generated continue to pygeoapi\nmake SCRIPT_NAME empty from /\nStart gunicorn name=pygeoapi on 0.0.0.0:80 with 4 workers and SCRIPT_NAME=\n[2022-08-09 12:59:00 +0000] [1] [INFO] Starting gunicorn 20.0.4\n[2022-08-09 12:59:00 +0000] [1] [INFO] Listening at: http://0.0.0.0:80 (1)\n[2022-08-09 12:59:00 +0000] [1] [INFO] Using worker: gevent\n[2022-08-09 12:59:00 +0000] [18] [INFO] Booting worker with pid: 18\n[2022-08-09 12:59:00 +0000] [19] [INFO] Booting worker with pid: 19\n[2022-08-09 12:59:00 +0000] [21] [INFO] Booting worker with pid: 21\n[2022-08-09 12:59:00 +0000] [22] [INFO] Booting worker with pid: 22\n</code></pre> </p> <p>That's all! Open your browser and navigate to http://localhost:5000, the pygeoapi page will display. As part of the initial <code>docker run</code>, Docker will download the pygeoapi Docker image from Docker hub. This may take some time, as the Docker image includes all dependencies (such as GDAL, etc.). Be patient! This is a one-time download for the entire workshop, or you may want to do this beforehand. </p> <p>Some notes:</p> <ul> <li>Docker runs a pygeoapi container on your local system on port 5000, which is mapped to port 80 inside the container</li> <li>the pygeoapi Docker container runs with the default configuration and data from the GitHub repo </li> <li>both configuration and data (from GitHub repo) is embedded in the Docker image - we will override these later</li> <li>the <code>--rm</code> option removes the Docker Container (but not the image), after execution</li> <li>type <code>CTRL-C</code> to stop the container and return to the terminal</li> </ul> <p>Next, you can override the default configuration and add your own data using Docker volumes.</p>"},{"location":"setup/#customizing-configuration","title":"Customizing configuration","text":"<p>In the upcoming exercises we are going to update the configuration file multiple times. For ease of development we are overriding the pygeoapi configuration which resides by default at <code>/pygeoapi/local.config.yml</code> within the container by a local file which you can edit in your favourite text editor. </p> <p>Override the pygeoapi config file</p> <p>Download pygeoapi's default Docker configuration from default.config.yml to the current folder (or navigate to the folder where you downloaded the file), for example with:</p> <p>Note</p> <p>If you do not have curl installed, copy the URL above to your web browser and save locally.</p> <p>Open the file in your favourite text editor and change the title and description of the API:</p> <pre><code>metadata:\n    identification:\n        title: My first pygeoapi run\n        description: pygeoapi provides an API to geospatial data\n</code></pre> <p>Now run the container with the overridden config file (on Linux/Mac):</p> <p>Running pygeoapi with a custom configuration</p> Linux/MacWindows <p> <pre><code>docker run -p 5000:80 \\\n-v $(pwd)/default.config.yml:/pygeoapi/local.config.yml \\\ngeopython/pygeoapi:latest\n</code></pre> </p> <p> <pre><code>docker run -p 5000:80 -v ${pwd}/default.config.yml:/pygeoapi/local.config.yml geopython/pygeoapi:latest\n</code></pre> </p> <p>At this point, navigate to http://localhost:5000 to verify the new title and description.</p> <p>By using a Docker volume mount (<code>-v</code> option), Docker attaches or 'mounts' a directory or single file from your host/local system into the Docker Container.</p> <p>In the above snippet, <code>$(pwd)</code> or <code>${pwd}</code> indicates the working folder from which you start the Docker container.</p>"},{"location":"setup/#adding-data-and-setting-the-configuration-file","title":"Adding data and setting the configuration file","text":"<p>In addition to adapting the configuration you will usually add your own data as files or remote data services like PostGIS or WFS.</p> <p>You can also mount a local directory such as <code>data/</code> to <code>/pygeoapi/mydata</code> within the Container. Within the data directory you can store vector data, raster files or sets of image or vector tiles.</p> <p>Below is an example where the configuration is explictly set to <code>pygeoapi-config.yml</code> via an environment variable (<code>-e</code>) and uses a Docker mount to mount the local <code>data</code> folder as <code>/pygeoapi/mydata</code>:</p> <p>Running pygeoapi with custom configuration</p> Linux/MacWindows <p> <pre><code>docker run -p 5000:80 \\\n-v $(pwd)/data:/pygeoapi/mydata \\\n-v $(pwd)/default.config.yml:/pygeoapi/pygeoapi-config.yml \\\n-e  PYGEOAPI_CONFIG=/pygeoapi/pygeoapi-config.yml \\\ngeopython/pygeoapi:latest\n</code></pre> </p> <p> <pre><code>docker run -p 5000:80 -v ${pwd}/data:/pygeoapi/mydata -v ${pwd}/default.config.yml:/pygeoapi/pygeoapi-config.yml -e PYGEOAPI_CONFIG=/pygeoapi/pygeoapi-config.yml geopython/pygeoapi:latest\n</code></pre> </p> <p>In the next sections we will review additional examples of mounts to the data folder. More Docker deployment examples can be found in the pygeoapi GitHub repository.</p>"},{"location":"setup/#using-docker-for-python-clients","title":"Using Docker for Python Clients","text":"<p>In some exercises we access <code>pygeoapi</code> remote endpoints using OWSLib,  a Python library to interact with OGC Web Services. <code>OWSLib</code> can be installed using standard  Python <code>pip3 install OWSLib</code>, but you may not have Python available, or you want to keep your system 'clean'.</p> <p>As Docker is already available on your system, you can start up a  Container with a complete Python environment, and access it from a <code>bash</code> shell prompt.  The magic line is:</p> <p><code>docker run -it --rm --network=host --name owslib python:3.10-slim /bin/bash</code></p> <p>This will pull a small (125MB) official Python Docker image. When the Container is started you are directed into  a <code>Bash</code> session/prompt. The argument <code>--network=host</code> allows you to directly interact with services on your host system, thus with <code>pygeoapi</code>, without setting up a Docker network. From there you can start <code>python3</code>, install <code>OWSLib</code> and maybe even other tools like <code>curl</code> and <code>wget</code>.</p> <p>Below is a complete example, assuming pygeoapi runs on your <code>localhost</code> at port 5000:</p> <pre><code>docker run -it --rm --network=host --name owslib python:3.10-slim /bin/bash\n\nUnable to find image 'python:3.10-slim' locally\n3.10-slim: Pulling from library/python\n5b5fe70539cd: Pull complete \nf4b0e4004dc0: Pull complete \nc5424f0ac885: Pull complete \n9d21fe1624ec: Pull complete \nde0194aa1c21: Pull complete \nDigest: sha256:7dc5b4e948acd18c1633b0e593ad0224298646612ce7d0b5ac6d4e17616d7e4b\nStatus: Downloaded newer image for python:3.10-slim\n\nroot@docker-desktop:/# pip3 install owslib\nroot@docker-desktop:/# python3\n&gt;&gt;&gt; from owslib.ogcapi.features import Features\n&gt;&gt;&gt; w = Features('http://localhost:5000')\n&gt;&gt;&gt; w\n&lt;owslib.ogcapi.features.Features object at 0x7ff493e6f850&gt;\n&gt;&gt;&gt; conformance = w.conformance()\n&gt;&gt;&gt; conformance\n&gt;&gt;&gt; quit()\n</code></pre> <p>Type <code>exit</code> to return to exit the owslib docker container.</p> <p>We will refer to this installation in some of the Exercises where OWSLib is used.</p> <ol> <li> <p>alternatively, you can fork/clone the GitHub repository of this workshop directly from https://github.com/geopython/diving-into-pygeoapi.\u00a0\u21a9</p> </li> <li> <p>For recent version of Docker run <code>docker compose version</code> \u21a9</p> </li> </ol>"},{"location":"standards/","title":"Overview","text":"<p>This section provides a high level overview of pygeoapi standards support.</p>"},{"location":"standards/#standards","title":"Standards","text":"<p>Open standards are core to pygeoapi. Open standards allow for broad interoperability and plug and play capability. pygeoapi supports a number of open standards (both formal and defacto or community driven).</p>"},{"location":"standards/#api-standards","title":"API standards","text":""},{"location":"standards/#ogc-api","title":"OGC API","text":"<p>pygeoapi implements the OGC API suite of standards from the Open Geospatial Consortium (OGC). From the OGC API website:</p> <p>Citation</p> <p>The OGC API family of standards are being developed to make it easy for anyone to provide geospatial data to the web. These standards build upon the legacy of the OGC Web Service standards (WMS, WFS, WCS, WPS, etc.), but define resource-centric APIs that take advantage of modern web development practices. This web page provides information on these standards in a consolidated location.</p> <p>These standards are being constructed as \"building blocks\" that can be used to assemble novel APIs for web access to geospatial content. The building blocks are defined not only by the requirements of the specific standards, but also through interoperability prototyping and testing in OGC's Innovation Program. </p>"},{"location":"standards/#ogc-api-common","title":"OGC API - Common","text":"<p>OGC API - Common is a common framework used in all OGC API's.  OGC API - Common provides the following functionality:</p> <ul> <li>based on OpenAPI 3.0</li> <li>HTML and JSON as the dominant encodings, alternative encodings are possible</li> <li>shared endpoints such as:<ul> <li><code>/</code> (landing page)</li> <li><code>/conformance</code></li> <li><code>/openapi</code></li> <li><code>/collections</code></li> <li><code>/collections/foo</code></li> </ul> </li> <li>aspects such as pagination, links between resources, basic filtering, query parameters (<code>bbox</code>, <code>datetime</code>, etc.)</li> </ul> <p>OGC API - Common allows for specification developers to focus on the key functionality of a given API (i.e. data access, etc.) while using common constructs. This harmonizes OGC API standards and enables deeper integration with less code. This also allows for OGC API client software to be more streamlined.</p> <p>The <code>/conformance</code> endpoint indicates which standards and extensions are supported by a deployment of OGC API.</p>"},{"location":"standards/#ogc-api-building-blocks","title":"OGC API building blocks","text":"<p>The OGC API approach allows for modularity and \"profiling\" of APIs depending on your requirements.  This means you can mix and match OGC APIs together.</p> <p></p> <p>You can read more about this topic in the building blocks website.</p>"},{"location":"standards/#more-ogc-apis","title":"More OGC APIs","text":"<p>The OGC API effort is rapidly evolving. Numerous OGC API standards are in development, and will be implemented in pygeoapi over time:</p> <ul> <li>Maps can serve spatially referenced and dynamically rendered map imagery</li> <li>Routes provides access to routing data</li> <li>Styles defines a Web API that enables map servers, clients as well as visual style editors, to manage and fetch styles</li> <li>3D GeoVolumes facilitates efficient discovery of and access to 3D content in multiple formats based on a space-centric perspective</li> <li>Moving Features defines an API that provides access to data representing features that move as rigid bodies</li> <li>Joins  supports the joining of data, from multiple sources, with feature collections or directly with other input files</li> <li>Discrete Global Grid System enables applications to organise and access data arranged according to a Discrete Global Grid System (DGGS)</li> </ul> <p></p>"},{"location":"standards/#ogc-apis-supported-by-pygeoapi","title":"OGC APIs supported by pygeoapi","text":"<p>pygeoapi is an OGC API Reference Implemetnation and implements numerous OGC API standards.</p> Standard pygeoapi status Included in this workshop OGC API - Features Reference \u2705 OGC API - Coverages Implementing \u2705 OGC API - Tiles Implementing \u2705 OGC API - Maps Implementing \u2705 OGC API - Processes Implementing \u2705 OGC API - Records Implementing \u2705 OGC API - Environmental Data Retrieval Reference \u2705 SpatioTemporal Asset Catalog Implementing OGC API - Routes Planned OGC API - Styles Planned <p>In the next section we will dive into the dedicated API's related to specific types of information. You will notice that all APIs are combined and available via a single OGC API endpoint, thanks to OGC API - Common.</p>"},{"location":"standards/#openapi","title":"OpenAPI","text":"<p>Core to OGC API - Common is the OpenAPI initiative to help describe and document an API. OpenAPI defines its structure in an OpenAPI document.  OGC API - Common suggests this document to be located at <code>/openapi</code>. With pygeoapi in a browser  this URL opens an interactive HTML page which facilitates  an API query. Append <code>?f=json</code> to view the document in JSON. The OpenAPI document indicates which endpoints are available in the service, which parameters it accepts and  what types of responses can be expected. The OpenAPI document is a similar concept to Capabilities XML as part of the first genration OGC Web Service standards.</p> <p>OpenAPI Specification parsing in a browser</p> <p>A common approach to interact with Open API's using json is to use a program like  Postman. Also there are browser plugins which enable to define api  requests interactively within a browser. For firefox download the plugin  poster. For Chrome  and Edge use Boomerang.  In Boomerang you can create individual web requests, but also load the open api specification  document and interact with any of the advertised endpoints. </p> <p>The OpenAPI community provides various tools, such as a validator for OAS documents or  generate code as a starting point for client development.</p>"},{"location":"standards/#content-and-format-standards","title":"Content and format standards","text":"<p>JSON is core in pygeoapi, providing a format that is machine readable and easy to parse and handle by client software and tools.  OGC API - Common provides uniform JSON formats for the various endpoints it supports.  Specific OGC API standards may specify domain specific formats (for example, GeoJSON for OGC API - Features, GeoTIFF for OGC API - Coverages) depending on the data type(s).</p>"},{"location":"standards/#pygeoapi-specific-conventions","title":"pygeoapi specific conventions","text":"<p>pygeoapi provides some conventions that are not put forth by OGC API standards, however facilitate some features and capabilities.</p>"},{"location":"standards/#the-f-parameter","title":"the <code>f</code> parameter","text":"<p>The <code>f</code> parameter can be used with any pygeoapi endpoint to specify an output format for a given   API request.  Examples are <code>f=html</code>, <code>f=json</code>, etc.</p> <p>Using a web browser to access OGC API</p> <p>Use your web browser to navigate to demo.pygeoapi.io. A browser by default opens  any OGC API in HTML (as a webpage) due to the HTTP Accept header  sent by the browser (<code>text/html</code>). On the right top corner you will notice a JSON link. The link  adds the parameter to the url: <code>f=json</code>, which is a mechanism of pygeoapi to override the HTTP Accept header sent by the web browser.</p> <p>Note</p> <p>When calling an OGC API from javascript, and the aim is to receive JSON, you can use the <code>?f=json</code> pygeoapi convention, or the content  negotiation as provided by the standard; include an HTTP header <code>Accept: \"application/json\"</code> in your request.</p> <p>In jQuery for example, this is represented by the dataType property:</p> <pre><code>$.ajax({\n    method: \"GET\",\n    url: \"https://demo.pygeoapi.io/master\",\n    dataType: \"json\"\n});\n</code></pre>"},{"location":"standards/#the-skipgeometry-parameter","title":"the <code>skipGeometry</code> parameter","text":"<p>The <code>skipGeometry</code> (<code>true|false</code>, default is <code>false</code>) parameter can be used with feature data access to facilitate downloading vector data without geometry if desired.</p>"},{"location":"standards/#summary","title":"Summary","text":"<p>Standards are a cornerstone of pygeoapi, and will enable you to publish your data efficiently and with a low barrier for users.  Now, let's get to the action: Publishing data!</p>"},{"location":"advanced/","title":"Advanced topics","text":"<p>In this section, we will discuss more advanced pygeoapi topics primarily focused on extending pygeoapi via custom development and deployment.</p> <ul> <li>Multilingual support</li> <li>CRS support</li> <li>UI customization and templating</li> <li>Using pygeoapi in downstream applications</li> <li>Search Engine Optimization (SEO)</li> <li>Security and access control</li> <li>Semantic Web and Linked Data</li> <li>Cloud deployment</li> <li>INSPIRE support</li> <li>pygeoapi as a Bridge to Other Services</li> </ul>"},{"location":"advanced/bridges/","title":"Exercise 9 - pygeoapi as a bridge to other services","text":"<p>In this section we explore how pygeoapi can be used as a facade, or a bridge, to re-publish web services with different interfaces. These bridges can help organisations migrating from OWS to OGC API.</p>"},{"location":"advanced/bridges/#publishing-wfs-as-ogc-api-features","title":"Publishing WFS as OGC API - Features","text":"<p>A powerful use case for pygeoapi is to provide an OGC API - Features interface over existing Web Feature Service (WFS)  or ESRI FeatureServer endpoints. In this scenario, you lower the barrier and increase the usability of existing services to  a wider audience. Let's set up an API on top of an existing WFS hosted by the city of Florence.</p> <p>Update the pygeoapi configuration</p> <p>Open the pygeoapi configuration in a text editor.  Find the line <code># START - EXERCISE 8 - WFS Proxy</code>.</p> <p>Add a new dataset section by uncommenting the lines up to <code># END - EXERCISE 8 - WFS Proxy</code>:</p> <pre><code>suol_epicentri_storici:\n    type: collection\n    title: Epicenters of the main historical earthquakes\n    description: Location of the epicenters of the main historical earthquakes in the territory of the Metropolitan City of Florence classified by year and intensity\n    keywords:\n        - earthquakes\n    links:\n        - type: text/xml\n          rel: canonical\n          title: Epicenters of the main historical earthquakes\n          href: http://pubblicazioni.cittametropolitana.fi.it/geoserver/territorio/wfs?request=getCapabilities&amp;service=WFS&amp;version=2.0.0\n          hreflang: it\n    extents:\n        spatial:\n            bbox: [10.94, 43.52, 11.65, 44.17]\n            crs: http://www.opengis.net/def/crs/OGC/1.3/CRS84\n    providers:\n        - type: feature\n          name: OGR\n          data:\n              source_type: WFS\n              source: WFS:http://pubblicazioni.cittametropolitana.fi.it/geoserver/territorio/wfs?\n              source_capabilities:\n                  paging: True\n              source_options:\n                  OGR_WFS_LOAD_MULTIPLE_LAYER_DEFN: NO\n              gdal_ogr_options:\n                  EMPTY_AS_NULL: NO\n                  GDAL_CACHEMAX: 64\n                  CPL_DEBUG: NO\n          id_field: cpti_id\n          crs:\n            - http://www.opengis.net/def/crs/OGC/1.3/CRS84\n            - http://www.opengis.net/def/crs/EPSG/0/4258\n            - http://www.opengis.net/def/crs/EPSG/0/3857\n            - http://www.opengis.net/def/crs/EPSG/0/3003\n          storage_crs: http://www.opengis.net/def/crs/EPSG/0/3003\n          title_field: d\n          layer: territorio:suol_epicentri_storici\n</code></pre> <p>Save the file and restart Docker Compose. Navigate to http://localhost:5000/collections to evaluate whether the new dataset has been published.</p> <p>Note these important configuration slices under <code>providers</code>:</p> <ul> <li> <p>We use the pygeoapi OGR Provider.  This is the most versatile backend of pygeoapi for supporting numerous formats. Using the GDAL/OGR library (Python bindings) allows pygeoapi to connect to around 80+ Vector Formats. We could have used the <code>OGR</code> Provider instead of the <code>SQLiteGPKG</code> Provider above in the <code>osm_places-vec</code> exercise above.</p> </li> <li> <p><code>storage_crs</code> denotes the CRS (Coordinate Reference System) in which the dataset is stored (default is CRS84, i.e. 'longitude, latitude') </p> </li> <li><code>crs</code> is an array of CRSs that can be specified for the Features to be returned (<code>crs=</code> parameter), or for their bounding box (<code>bbox-crs=</code> parameter). Default is also CRS84.</li> </ul> <p>CRS support effectively allows pygeoapi to reproject the data from its storage CRS (here EPSG:3003) according to OGC API - Features - Part 2: Coordinate Reference Systems by Reference. The Advanced section of this workshop will further elaborate pygeoapi CRS support.</p>"},{"location":"advanced/bridges/#publishing-wms-as-ogc-api-maps","title":"Publishing WMS as OGC API - Maps","text":"<p>We can use the pygeoapi's WMSFacade provider to publish OGC Web Map Service (WMS) interfaces as OGC API - Maps.</p> <p>Let's set up an API on top of an existing WMS on the MapServer Demonstration Server:</p> <p>https://demo.mapserver.org/cgi-bin/msautotest</p> <p>Note</p> <p>Feel free to use an WMS of your choice, as you wish!</p> <p>Update the pygeoapi configuration</p> <p>Open the pygeoapi configuration in a text editor.  Find the line <code>## START - EXERCISE 8 - WMS Proxy</code>.</p> <p>Add a new dataset section by uncommenting the lines up to <code>## END - EXERCISE 8 - WMS Proxy</code>:</p> <p>Be sure to keep the proper YAML indentation.</p> <pre><code>wms-facade-demo:\n    type: collection\n    title: WMS Facade demo\n    description: WMS Facade demo\n    keywords:\n        - WMS facade\n    links:\n        - type: text/html\n          rel: canonical\n          title: MapServer\n          href: https://mapserver.org\n          hreflang: en\n    extents:\n        spatial:\n            bbox: [-180,-90,180,90]\n            crs: http://www.opengis.net/def/crs/OGC/1.3/CRS84\n    providers:\n        - type: map\n          name: WMSFacade\n          data: https://demo.mapserver.org/cgi-bin/msautotest\n          options:\n              layer: world_latlong\n              style: default\n          format:\n              name: png\n              mimetype: image/png\n</code></pre> <p>Run the following requests in your web browser:</p> <ul> <li>default map: http://localhost:5000/collections/wms-facade-demo/map?f=png</li> <li>specific width/height: http://localhost:5000/collections/wms-facade-demo/map?f=png&amp;width=800&amp;height=600</li> <li>specific area of interest (bbox of Canada): http://localhost:5000/collections/wms-facade-demo/map?f=png&amp;width=800&amp;height=600&amp;bbox=-142,42,-52,84</li> </ul> <p></p> <p>Tip</p> <p>Try with your own bbox and width/height values!</p>"},{"location":"advanced/bridges/#publishing-csw-as-ogc-api-records","title":"Publishing CSW as OGC API - Records","text":"<p>In this section we'll have a look at how to publish Catalogue Service for the Web (CSW) as OGC API - Records. For that, we will use the pycsw OGC CITE demo CSW service.</p> <p>Update the pygeoapi configuration</p> <p>Open the pygeoapi configuration in a text editor.  Find the line <code># START - EXERCISE 8 - CSW Proxy</code>.</p> <p>Add a new dataset section by uncommenting the lines up to <code># END - EXERCISE 8 - CSW Proxy</code>:</p> <pre><code>cite_demo:\n    type: collection\n    title: pycsw OGC CITE demo and Reference Implementation\n    description: pycsw is an OARec and OGC CSW server implementation written in Python. pycsw fully implements the OGC API - Records and OpenGIS Catalogue Service Implementation Specification (Catalogue Service for the Web). Initial development started in 2010 (more formally announced in 2011). The project is certified OGC Compliant, and is an OGC Reference Implementation. Since 2015, pycsw is an official OSGeo Project. pycsw allows for the publishing and discovery of geospatial metadata via numerous APIs (CSW 2/CSW 3, OpenSearch, OAI-PMH, SRU). Existing repositories of geospatial metadata can also be exposed, providing a standards-based metadata and catalogue component of spatial data infrastructures. pycsw is Open Source, released under an MIT license, and runs on all major platforms (Windows, Linux, Mac OS X)\n    keywords:\n        - ogc\n        - cite\n        - compliance\n        - interoperability\n    extents:\n        spatial:\n            bbox: [-180,-90,180,90]\n            crs: http://www.opengis.net/def/crs/OGC/1.3/CRS84\n    providers:\n        - type: record\n        name: CSWFacade\n        data: https://demo.pycsw.org/cite/csw\n        id_field: identifier\n        time_field: datetime\n        title_field: title\n</code></pre> <p>You can explore the proxied catalogue collection using this endpoints:</p> <ul> <li>collection metadata page: http://localhost:5000/collections/cite_demo</li> <li>list of records: http://localhost:5000/collections/cite_demo/items</li> <li>record: http://localhost:5000/collections/cite_demo/items/urn:uuid:19887a8a-f6b0-4a63-ae56-7fba0e17801f</li> </ul> <p>Tip</p> <p>Remember that you can use the QGIS client suggested here to explore this API.</p>"},{"location":"advanced/bridges/#publishing-sensorthings-api-as-ogc-api-features","title":"Publishing SensorThings API as OGC API - Features","text":"<p>The OGC SensorThings API standard offers RESTfull interfaces to interconnect IoT devices, data, in an open and unified way. Although there are some clients that support this standard, there are many more that support OGC API - Features.</p> <p>The pygeoapi SensorThings bridge enables to proxy the SensorThings entities (e.g.:  <code>Thing</code> , <code>Sensor</code>, <code>DataStream</code>, <code>ObservedProperty</code> ) into feature collections.</p> <p>In this section we'll have a look at how to Publish a SensorThings API <code>Thing</code> as an OGC API - Features collection, which can then be consumed by various clients, like the ones listed here</p> <p>Update the pygeoapi configuration</p> <p>Open the pygeoapi configuration in a text editor.  Find the line <code># START - EXERCISE 8 - SensorThings Proxy</code>.</p> <p>Add a new dataset section by uncommenting the lines up to <code># END - EXERCISE 8 - SensorThings Proxy</code>:</p> <pre><code>toronto_bikes:\n    type: collection\n    title: Toronto Bikes SensorThings\n    description: The geographic location with coordinates for the Toronto bike share station\n    keywords:\n        - sediments\n    extents:\n        spatial:\n            bbox: [-180,-90,180,90]\n            crs: http://www.opengis.net/def/crs/OGC/1.3/CRS84\n    providers:\n        - type: feature\n            name: SensorThings\n            data: https://toronto-bike-snapshot.sensorup.com/v1.0/\n            entity: Things\n</code></pre>"},{"location":"advanced/cloud/","title":"Cloud deployment","text":"<p>Deployment to cloud infratructure and concepts such as Microservices and Twelve-Factor present specific requirements to how software is designed and implemented. pygeoapi supports these concepts, having a low footprint on CPU and memory, and does not persist user state, therefore being able to scale without risks.</p>"},{"location":"advanced/cloud/#pygeoapi-and-docker","title":"pygeoapi and Docker","text":"<p>A Docker image is available for pygeoapi. You can run the image locally as:</p> <pre><code>docker run -p 5000:80 geopython/pygeoapi:latest\n</code></pre> <p>Review the pygeoapi Dockerfile</p> <p>Notice in the pygeoapi Dockerfile how the open api file is generated as part of the Docker startup script. </p> <p>In a typical configuration one would override the default pygeoapi configuration file in the image with a customized one and include the data folder:</p> <p>using custom configuration</p> Linux/MacWindows <p> <pre><code>docker run -p 5000:80 \\ \n-v $(pwd)/pygeoapi-config.yml:/pygeoapi/local.config.yml \\\n-v $(pwd)/geodata:/geodata https://hub.docker.com/r/geopython/pygeoapi:latest\n</code></pre> </p> <p> <pre><code>docker run -p 5000:80 -v ${pwd}/pygeoapi-config.yml:/pygeoapi/local.config.yml -v ${pwd}/geodata:/geodata https://hub.docker.com/r/geopython/pygeoapi:latest\n</code></pre> </p> <p>Alternatively, you can build a fresh Docker image including both the configuration and data for the service. </p> <pre><code>FROM geopython/pygeoapi:latest\nCOPY ./my.config.yml /pygeoapi/local.config.yml\n</code></pre> <p>You may have noticed that the pygeoapi configuration file includes a reference to the endpoint on which pygeoapi is published. This configuration should match the public endpoint of the service (domain, path and port).</p> <p>By default the pygeoapi Docker image will run from the <code>root</code> path <code>/</code>. If you need to run from a sub-path and have all internal URLs correct you can set the <code>SCRIPT_NAME</code> environment variable.</p> <pre><code>docker run -p 5000:80 -e SCRIPT_NAME='/mypygeoapi' \\\n-v $(pwd)/my.config.yml:/pygeoapi/local.config.yml -it geopython/pygeoapi\n# browse to http://localhost:5000/mypygeoapi\n</code></pre>"},{"location":"advanced/cloud/#summary","title":"Summary","text":"<p>Congratulations! You can now deploy pygeopi as a cloud native service.</p>"},{"location":"advanced/crs/","title":"CRS support","text":"<p>Starting with version 0.15.0, pygeoapi fully supports OGC API - Features - Part 2: Coordinate Reference Systems by Reference. This enables the import and export of any data according to dedicated projections. A \"projection\" is specified with a Coordinate Reference System (CRS) identifier. These are in URI formats like <code>http://www.opengis.net/def/crs/OGC/1.3/CRS84</code> (basically WGS84 in longitude, latitude axis order) or the \"OpenGIS\" format like <code>http://www.opengis.net/def/crs/EPSG/0/4258</code>. Note that the \"EPSG:\" format like <code>EPSG:4326</code> is outside the scope of the OGC standard.</p> <p>In particular CRS support allows for the following:</p> <ul> <li>to specify the CRS in which the data is stored, in pygeoapi the <code>storageCRS</code> config option </li> <li>to specify the list of CRSs in which Feature data can be retrieved, in pygeoapi the <code>crs</code> config option</li> <li>to publish these CRSs in the collection metadata</li> <li>the <code>crs=</code> query parameter for a collection or collection item</li> <li>the <code>bbox-crs=</code> query parameter to indicate that the <code>bbox=</code> parameter is encoded in that CRS</li> <li>the HTTP response header <code>Content-Crs</code> denotes the CRS of the Feature(s) in the data returned</li> </ul> <p>So although GeoJSON mandates WGS84 in longitude, latitude order, the client and server may still agree on other CRSs.</p> <p>Under the hood, pygeoapi uses the well-known pyproj Python wrapper to the PROJ library.</p> <p>Read more in the pygeoapi documentation in the CRS Chapter.</p>"},{"location":"advanced/crs/#exercise","title":"Exercise","text":"<p>Adding CRS support to pygeoapi collections for the <code>provider</code> type <code>feature</code> is as simple as for example extending the Exercise 2 config with this snippet:</p> <pre><code>  crs:\n      - http://www.opengis.net/def/crs/OGC/1.3/CRS84\n      - http://www.opengis.net/def/crs/EPSG/0/4258\n      - http://www.opengis.net/def/crs/EPSG/0/3857\n      - http://www.opengis.net/def/crs/EPSG/0/4326\n  storage_crs: http://www.opengis.net/def/crs/OGC/1.3/CRS84\n</code></pre> <p>Axis</p> <p>Axis order (are coordinates it longitude, latitude or latitude, longitude order?) in projections is often a source of confusion.  However the URI format is quite clear on this, at least more than the <code>EPSG:</code> format. So http://www.opengis.net/def/crs/OGC/1.3/CRS84 is longitude, latitude order, while http://www.opengis.net/def/crs/EPSG/0/4326 is latitude, longitude order.</p> <p>In the config below, we basically indicate that the data is stored in WGS84 (longitude, latitude axis order) and can be retrieved in CRSs like <code>http://www.opengis.net/def/crs/EPSG/0/4258</code> (ETRS89 latitude, longitude axis order) etc.</p> <p>Add CRS to a pygeoapi configuration</p> <p>Open the pygeoapi configuration file in a text editor. Find the line <code># START - EXERCISE 2 - firenze-terrain</code></p> <p>Update the dataset section with CRS support by replacing it with the snippet below:</p> <pre><code>firenze-terrains-vec:\n    type: collection\n    title: Administrative boundaries before 2014\n    description: Cadastral parcels (terrains) from the cadastre. Territory Agency; SIT and Information Networks;\n    keywords:\n        - Cadastral parcels\n    links:\n        - type: text/html\n          rel: canonical\n          title: Administrative boundaries before 2014\n          href: http://dati.cittametropolitana.fi.it/geonetwork/srv/metadata/cmfi:c539d359-4387-4f83-a6f4-cd546b3d8443\n          hreflang: it\n    extents:\n        spatial:\n            bbox: [11.23,43.75,11.28,43.78]\n            crs: http://www.opengis.net/def/crs/OGC/1.3/CRS84\n    providers:\n        - type: feature\n          name: SQLiteGPKG\n          data: /data/firenze_terrains.gpkg # place correct path here\n          id_field: fid\n          crs:\n            - http://www.opengis.net/def/crs/OGC/1.3/CRS84\n            - http://www.opengis.net/def/crs/EPSG/0/4258\n            - http://www.opengis.net/def/crs/EPSG/0/3857\n            - http://www.opengis.net/def/crs/EPSG/0/4326\n          storage_crs: http://www.opengis.net/def/crs/OGC/1.3/CRS84\n          title_field: codbo\n          table: firenze_terrains\n</code></pre> <p>Now we can inspect the collection metadata and retrieve Features in various CRSs. We can even do this in the Swagger UI, but using the browser is quite fast and clear.</p>"},{"location":"advanced/crs/#metadata","title":"Metadata","text":"<p>Collection Metadata</p> <p>Open the URL:  http://localhost:5000/collections/firenze-terrains-vec Your configured CRSs are displayed at the bottom of the page: \"Reference Systems\" and \"Storage CRS\".</p> <p>See these in JSON format, also at the bottom:  http://localhost:5000/collections/firenze-terrains-vec?f=json <pre><code>   .\n   .\n   \"crs\":[\n    \"http://www.opengis.net/def/crs/OGC/1.3/CRS84\",\n    \"http://www.opengis.net/def/crs/EPSG/0/4258\",\n    \"http://www.opengis.net/def/crs/EPSG/0/3857\",\n    \"http://www.opengis.net/def/crs/EPSG/0/4326\"\n   ],\n   \"storageCRS\":\"http://www.opengis.net/def/crs/OGC/1.3/CRS84\"\n }\n</code></pre></p>"},{"location":"advanced/crs/#reproject-features","title":"Reproject Features","text":"<p>Using the CRS query parameter</p> <p>Open the URL:  http://localhost:5000/collections/firenze-terrains-vec/items?f=json&amp;crs=http://www.opengis.net/def/crs/EPSG/0/4258</p> <p>This is ETRS89, similar to WGS84, but for the European Continent (Datum) and in lat,lon order. This is e.g. used in INSPIRE.</p> <p>See these in JSON format, also at the bottom:</p> <pre><code>\"type\":\"FeatureCollection\",\n  \"features\":[\n      {\n          \"type\":\"Feature\",\n          \"geometry\":{\n              \"type\":\"MultiPolygon\",\n              \"coordinates\":[\n                  [\n                      [\n                          [\n                              43.77805936835436,\n                              11.23486287997071\n                          ],\n                          [\n                              43.77809089595012,\n                              11.2348943159564\n                          ],\n                          [\n                              43.77810038978989,\n                              11.23491359066035\n                          ],\n                          [\n                              43.77705757917591,\n                              11.2368990806804\n   .\n   .\n   \"crs\":[\n    \"http://www.opengis.net/def/crs/OGC/1.3/CRS84\",\n    \"http://www.opengis.net/def/crs/EPSG/0/4258\",\n    \"http://www.opengis.net/def/crs/EPSG/0/3857\",\n    \"http://www.opengis.net/def/crs/EPSG/0/4326\"\n   ],\n   \"storageCRS\":\"http://www.opengis.net/def/crs/OGC/1.3/CRS84\"\n }\n</code></pre> <p>If you open the browser development console, you can observe the HTTP response header:</p> <p><code>Content-Crs: &lt;http://www.opengis.net/def/crs/EPSG/0/4258&gt;</code></p> <p>(The CRS URI is always enclosed in <code>&lt;</code> <code>&gt;</code>)</p>"},{"location":"advanced/downstream-applications/","title":"Using pygeoapi in downstream applications","text":"<p>While pygeoapi is typically run as a standalone application, it is also designed to enable direct usage via external Python applications in a number of different design patterns.at multiple levels. From the official documentation, the below diagram provides an overview of how pygeoapi is designed and architected:</p> <p></p> <p>There are two main ways to create a downstream application:</p> <ul> <li>Using the core API</li> <li>Extending through the web interface of the frameworks supported out-of-the box</li> </ul>"},{"location":"advanced/downstream-applications/#using-the-core-api-directly","title":"Using the core API directly","text":"<p>The core pygeoapi Python API entrypoint is <code>pygeoapi.api.API</code>, which is initialized with the pygeoapi configuration as a Python <code>dict</code>.</p> <p>Note</p> <p>The pygeoapi core API enables the developer to manage pygeoapi configuration in any number of ways (file on disk, object storage, database driven, etc.)</p> <p>From here, API objects provide a number of functions, most of which require a <code>pygeoapi.api.APIRequest</code> object according to the web framework. Examples include:</p> <ul> <li>Flask</li> <li>Starlette</li> <li>FastAPI</li> <li>Django</li> </ul> <p>Note</p> <p>See the official documentation for more information about <code>pygeoapi.api.APIRequest</code> (you can even use your own custom request object as long as it satisfies the interface requirements of <code>pygeoapi.api.APIRequest</code>.</p> <p>Let's take a look at what a bare bones API integration would look like, using Flask as an example:</p> <pre><code>from flask import Flask, make_response, request\n\nfrom pygeoapi.api import API\nfrom pygeoapi.util import yaml_load\n\nmy_flask_app = Flask(__name__)\n\nwith open('my-pygeoapi-config.yml') as fh:\n    my_pygeoapi_config = yaml_load(fh)\n\nmy_pygeoapi_api = API(my_pygeoapi_config)\n\n@my_flask_app.route('/my-landing-page-route')\ndef my_def():\n\n    headers, status, content = my_pygeoapi_api.landing_page(request)\n\n    response = make_response(content, status)\n\n    if headers: \n        response.headers = headers\n\n    return response\n</code></pre> <p>Note</p> <p>See the official documentation for more information on the core Python API</p>"},{"location":"advanced/downstream-applications/#extending-through-a-web-framework","title":"Extending through a web framework","text":"<p>pygeoapi can be installed and used at the web routing level as a dependency in your project. This is pretty much the easier way to leverage the flexibility and the modularity of its architecture. Once the interfaces are available then the developer can use the preferred framework for serving the frontend application. In practice the following modules:</p> <ul> <li><code>pygeoapi.flask_app.py</code> for Flask blueprints</li> <li><code>pygeoapi.starlette_app.py</code> for Starlette/FastAPI</li> <li><code>pygeoapi.django_app.py</code> for Django (ongoing PR)</li> </ul> <p>Some examples are available below for developers.</p>"},{"location":"advanced/downstream-applications/#examples","title":"Examples","text":""},{"location":"advanced/downstream-applications/#flask-blueprints","title":"Flask blueprints","text":"<pre><code>from flask import Flask\n\nfrom pygeoapi.flask_app import BLUEPRINT as pygeoapi_blueprint\n\nmy_flask_app = Flask(__name__, static_url_path='/static')\nmy_flask_app.url_map.strict_slashes = False\n\n# mount all pygeoapi endpoints to /oapi\nmy_flask_app.register_blueprint(pygeoapi_blueprint, url_prefix='/oapi')\n\n\n@my_flask_app.route('/')\ndef home():\n    return '&lt;p&gt;home page&lt;/p&gt;'\n</code></pre>"},{"location":"advanced/downstream-applications/#starlette-and-fastapi","title":"Starlette and FastAPI","text":"<pre><code>import uvicorn\nfrom fastapi import FastAPI\nfrom fastapi.exceptions import RequestValidationError\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\nfrom starlette.middleware.cors import CORSMiddleware\n\nfrom pygeoapi.starlette_app import app as pygeoapi_app\n\n\ndef create_app() -&gt; FastAPI:\n    \"\"\"Handle application creation.\"\"\"\n    app = FastAPI(title=\"my_pygeoapi\", root_path=\"\", debug=True)\n\n    # Set all CORS enabled origins\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\n    @app.exception_handler(StarletteHTTPException)\n    async def custom_http_exception_handler(request, e):\n        return await http_exception_handler(request, e)\n\n    @app.exception_handler(RequestValidationError)\n    async def custom_validation_exception_handler(request, e):\n        return await request_validation_exception_handler(request, e)\n\n    # mount all pygeoapi endpoints to /oapi\n    app.mount(path=\"/oapi\", app=pygeoapi_app)\n\n    return app\n\napp = create_app()\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, port=5000)\n</code></pre>"},{"location":"advanced/i18n/","title":"Multilingual support","text":"<p>pygeoapi supports multilinguality at three levels:</p> <ul> <li>In the pygeoapi configuration you can provide titles and abstracts of the service and collections in multiple languages.</li> <li>A set of translatable text-strings which are translated and introduced as part of the JSON and HTML output formats. Translations are managed by the Babel framework</li> <li>Column names/values in feature based datasets. If a dataset contains columns in multiple languages, pygeoapi will try to return data responses in the requested language</li> </ul> <p>Note</p> <p>Error messages are not translated, to facilitate copy-paste of the error into  stackoverflow and  GitHub issues.</p> <p>Language negotiation is triggered by the HTTP <code>Accept-Language</code> header as sent by the client, and can always be overridden with the <code>?lang=fr</code> url parameter.</p>"},{"location":"advanced/i18n/#multilingual-configuration","title":"Multilingual configuration","text":"<p>In the pygeoapi configuration you can indicate the languages supported by the instance. The first language is the default language. For most of the textual configuration properties you can provide a translation in alternative languages.</p> <pre><code>lakes:\n  type: collection\n  title:\n      en: Large Lakes\n      fr: Grands Lacs\n  description:\n      en: lakes of the world, public domain\n      fr: lacs du monde, domaine public\n  keywords:\n      en:\n          - lakes\n          - water bodies\n      fr:\n          - lacs\n          - plans d'eau\n</code></pre>"},{"location":"advanced/i18n/#text-strings-within-jinja2-html-templates","title":"Text strings within Jinja2 HTML templates","text":"<p>Most of the translatable text strings exist within the Jinja2 HTML templates. Text strings to be translated are placed in a <code>trans</code> tag, as follows:</p> <pre><code>&lt;title&gt;{% trans %}Page title{% endtrans %}&lt;/title&gt;\n</code></pre> <p>Babel provides a utility which extracts all keys to be translated from the templates into a single <code>.pot</code> file. </p> <pre><code>pybabel extract -F babel-mapping.ini -o locale/messages.pot ./\n</code></pre> <p>The resulting <code>.pot</code> file is used to create or update existing <code>.po</code> files, which exist for each language, containing the actual translations.</p> <pre><code>pybabel init -d locale -l it -i locale/messages.pot\n</code></pre> <p>The <code>.po</code> files are stored in pygeoapi's source code repository on GitHub. You can create a Pull Request to add or update your favourite languages. <code>.po</code> files can also be added to translation software such as transifex.com. </p> <p>Edit a <code>.po</code> file</p> <p>Open a <code>.po</code> file from the locale folder in a text editor. Edit some values. Save the file and restart the service. Verify that the updated content is available. You can also try to add a new key to a template and translate it via the <code>.po</code> mechanism.</p>"},{"location":"advanced/i18n/#annotating-the-language-of-data-columns","title":"Annotating the language of data columns","text":"<p>pygeoapi includes a meachanism to influence the API responses based on the requested language. If your service operates with multilingual requirements, it may make sense to add textual columns in multiple languages. For example, in the pygeoapi configuration you can then indicate which column should be used as the title field, for which language. </p> <p>Publish a multilingual dataset</p> <p>For this workshop we have prepared a multilingual dataset of <code>free wifi hotspots in Florence</code> (<code>workshop/exercises/data/free-wifi-florence.csv</code>). Add the dataset to the pygeoapi configuration using the CSV provider. Add a title-field configuration with for each translated column the relevant language.</p> <pre><code>data: /data/free-wifi-florence.csv\nid_field: id\ntitle_field: \n  en: name-en\n  it: name-it\n  de: name-de\n</code></pre> <p>Test the configuration by navigating to the items page of the collection and switching the language by appending <code>?lang=it</code>, <code>?lang=de</code> to the URL.</p>"},{"location":"advanced/i18n/#summary","title":"Summary","text":"<p>Congratulations! You've customized pygeoapi to support multiple languages.</p>"},{"location":"advanced/inspire/","title":"INSPIRE support","text":"<p>INSPIRE is a European directive on data sharing in the environmental domain. EU member states  have invested almost 20 years of effort to harmonize data in the environmental domain and publish it using OGC standards.  The directive is at the end of its lifetime, but the expectation is that conventions from the INSPIRE directive will be adopted  by upcoming directives, such as green deal and open data directives. </p> <p>In the past 20 years, the IT landscape has changed considerably. INSPIRE has followed these developments by adopting a  series of Good Practices which supersede the original  Technical Guidelines.</p> <p>Some of the recent and upcoming good practices focus on the developments in the OGC API domain.  One good practice has already been adopted on providing  download services using OGC API - Features  and others are in preparation, such as the  discovery service using OGC API - Records.  These developments make pygeoapi an interesting option  for providing INSPIRE services.</p>"},{"location":"advanced/inspire/#inspire-services-and-their-ogc-api-alternative","title":"INSPIRE services and their OGC API alternative","text":"<p>INSPIRE services are typically categorized in view services, download services and discovery services.  Download services are further devided in Vector sources, Coverage sources and Sensor sources. The OGC API initiative provides the related APIs for each service. The table below highlights for each service type the Technical Guidenace recommendation and the relevant Good Practices. </p> Service type TG OGC API Good practice status Discovery service CSW OGC API - Records In preparation View service WM(T)S OGC API - Maps / OGC API - Tiles Not scheduled In preparation Download service - Vector WFS OGC API - Features Adopted Download service - Coverage WCS OGC API - Coverages / STAC Not scheduled In preparation Download service - Sensor SOS OGC API - EDR / Sensorthings API <sup>1</sup> Not scheduled Adopted <p>Note</p> <p>When adopting Good Practices, consider that the documentation and tools for validation are still limited.  Also the INSPIRE GeoPortal may not be ready to harvest records from an OGC API - Records endpoint yet. </p> <p>Publish metadata documents as an INSPIRE discovery service</p> <p>In this exercise we will import a folder of metadata documents into a TinyDB database and configure the database as an OGC API - Records endpoint.  Download the zipfile 'inspire-records.zip' from the repository. Expand the zipfile. The <code>/tests</code> folder contains a script  load_tinydb_records.py. The script has 2 parameters:</p> <p> <pre><code>python3 load_tinydb_records.py &lt;path/to/xml-files&gt; &lt;output.db&gt;\n</code></pre> </p> <p>Now configure TinyDB as a provider for OGC API - Records. Restart the service and verify the result. Verify also the XML output of some of the records. </p>"},{"location":"advanced/inspire/#ogc-api-and-the-inspire-data-models","title":"OGC API and the INSPIRE data models","text":"<p>Most of the INSPIRE data models have a hierarchical structure, which is not common in the GeoJSON oriented OGC API community.  In theory it is possible to provide hierarchical GML from an OGC API endpoint, but there are not many experiences yet currently. Two initiatives may bring improvement to this aspect:</p> <ul> <li>pygeoapi facilitates to configure a JSON-LD encoding using an arbitrary ontology. The  good practice on semantic web provides some of the data models in an RDF ontology</li> <li>The good practice on alternative encodings suggests an  approach to publish datasets using a relational data model such as GeoPackage, which fits better with the OGC API community</li> </ul>"},{"location":"advanced/inspire/#ogc-api-as-a-codelist-registry","title":"OGC API as a codelist registry","text":"<p>A typical use case in INSPIRE is the option to extend an INSPIRE codelist to match a local requirement. For this use case the  extended codelist has to be published in a registry. OGC API - Common provides mechanisms to publish lists of concepts as items  in collections. pygeoapi also provides a mechanism to advertise the concepts using the SKOS ontology via its JSON-LD  encoding. In the coincidence that a concept has a geometry property, the codelist can even be published as OGC API - Features  (on a map).</p> <p>Publish a codelist via OGC API</p> <p>A German Soiltype codelist has been made available in CSV format in <code>workshop/exercises/data/bodenart.en.csv</code>. Use the CSV provider to publish this dataset in pygeoapi. Which URL would you use to reference a concept in the published list?</p> <pre><code>SoilTypes:\n    type: collection\n    title: Soil types of Germany\n    description: Bodenarten auf Basis der Bodenkundlichen Kartieranleitung 5. Auflage (KA5)\n    keywords:\n        - soiltype\n    links:\n        - type: text/html\n          rel: canonical\n          title: Soil types of Germany\n          href: https://registry.gdi-de.org/codelist/de.bund.thuenen/bodenart\n          hreflang: de\n    extents:\n        spatial:\n            bbox: [0,0,0,0]\n            crs: http://www.opengis.net/def/crs/OGC/1.3/CRS84\n    providers:\n        - type: feature\n          name: CSV\n          data: /data/bodenart.en.csv\n          id_field: Label\n          geometry:\n              x_field: x\n              y_field: y\n</code></pre>"},{"location":"advanced/inspire/#summary","title":"Summary","text":"<p>Congratulations! You have worked with pygeoapi for INSPIRE compliance</p> <ol> <li> <p>Sensorthings API and is not an OGC API standards and is currently not supported by pygeoapi. It is listed here for completeness\u00a0\u21a9</p> </li> <li> <p>STAC is not OGC API standard but is supported by pygeoapi\u00a0\u21a9</p> </li> </ol>"},{"location":"advanced/security-access-control/","title":"Security and access control","text":"<p>Security in general is a broad and complex topic, affecting the entire development lifecycle. It is recommended to follow security best practices during all development phases like design, coding and deployment. In this workshop we will focus only on API security and access control, rather than the full range of application security topics.</p> <p>Application Security</p> <p>The Open Web Application Security Project (OWASP) Top Ten document is a very good tool to ensure the bare minimum against the security risks and manage critical treats that are most likely affecting your code.</p> <p>API Security is the whole process to protect APIs from attacks. It is part of the more general security guidelines that are being treated in the OWASP Top Ten document. So those recommendations still apply.</p> <p>Access control is another fundamental part of the Open Web Application Security Project and addresses the Identity and Access Management (IAM) of an API. IAM consists of two different parts of a security flow:</p> <ul> <li>Authentication (AuthN) verifies the user's identity in order to allow or deny subsequent access (see next)</li> <li>Authorization (AuthZ) validates permissions of a user (identity) to access a resource. The permissions of that identity are checked against a resource's policies to (dis)allow access to, for example, (parts of) an API.</li> </ul> <p>These parts are usually managed by dedicated infrastructures and solutions which usually provide most of the security requirements out-of-the-box.</p> <p>OpenAPI Security Specification</p> <p>The OpenAPI specification has very well-defined elements for developers and adopters. The most relevant are:     - Security Scheme Object defines the security schemes that can be used by the operations. Supported schemes are HTTP Authentication, an API Key, OAuth2's flows and OpenID Connect.     - Security Requirement Object defines the list of required security schemes to execute an operation.</p>"},{"location":"advanced/semantic-web-linked-data/","title":"Semantic Web and Linked Data","text":"<p>This section touches on 3 aspects of the Semantic Web:</p> <ul> <li>Search engines</li> <li>Publish spatial data in the semantic web</li> <li>Proxy to semantic web</li> </ul>"},{"location":"advanced/semantic-web-linked-data/#search-engines","title":"Search engines","text":"<p>Search engines use technology similar to the Semantic Web to facilitate capturing structured data (aka rich snippets) from web pages. pygeoapi supports this use case via embedding a <code>schema.org</code> JSON-LD snippet in the HTML encoding,</p> <p>Tip</p> <p>The <code>schema.org</code> ontology is not a formal Semantic Web ontology, it is therefore a bit disconnected from the rest of the Semantic Web</p> <p>Tip</p> <p>See more information at Search Engine Optimization</p>"},{"location":"advanced/semantic-web-linked-data/#publish-spatial-data-in-the-semantic-web","title":"Publish spatial data in the Semantic Web","text":"<p>OGC API - Common adopted a number of W3C conventions, which bring OGC APIs closer to the standards of Semantic Web, compared to first generation OGC Web Service (OWS) standards.</p> <p>Currently, pygeaopi does not aim to be a full implementation of Semantic Web, however it is possible to advertise some aspects of the Semantic Web so the data can be traversed by Semantic Web aware clients.</p> <p>Use a SPARQL client to query pygeoapi</p> <p>SPARQL is commonly known as the query language to query triple stores.  However you can also use SPARQL to query graphs of linked web resources. The SPARQL client traverses links between  the resources to locate the requested triples. Jena ARQ is a command  line SPARQL client which is able to run such queries. Jena is quite difficult to set up, although there is a  Docker image available. As an alternative we will use a web-based implementation  of the ARQ engine. Navigate to https://demos.isl.ics.forth.gr/sparql-ld-endpoint and replace the query in the textbox with:</p> <pre><code>SELECT * WHERE { \n  SERVICE &lt;https://demo.pygeoapi.io/master/collections/lakes&gt; { \n    { \n    ?s ?p ?o  \n    } \n  } \n}\n</code></pre> <p>A query to an item returns the item with its geometry:</p> <pre><code>SELECT * WHERE { \n  SERVICE &lt;https://demo.pygeoapi.io/master/collections/lakes/items/1&gt; {\n    {{ ?s ?p ?o }}\n  }\n}\n</code></pre> <p>Notice that the SPARQL client fails if you hardcode the HTML format. </p> <pre><code>SELECT * WHERE { \n  SERVICE &lt;https://demo.pygeoapi.io/master/collections/lakes?f=html&gt; {\n    { ?s ?p ?o }\n  }\n}\n</code></pre> <p>JSON-LD as expected by search engines has some challenges for semantic web tools. So how does it work if the format is not hardcoded?  The SPARQL engine negotiates with the endpoint to evaluate which (RDF) encodings are available, and based on the content negotiation  it requests the <code>JSON_LD</code> encoding via <code>f=jsonld</code>.</p> <p>pygeoapi adopted conventions of the JSON-LD community to annotate JSON as RDF. For features, each property (column in a source table)  is annotated by a semantic concept. The related configuration to apply the annotations is managed in the context element of a resource definition</p> <p>Tip</p> <p>Read more in the pygeoapi documentation.</p> <pre><code>context:\n    - schema: https://schema.org/\n    stn_id: schema:identifer\n    datetime:\n        \"@id\": schema:observationDate\n        \"@type\": schema:DateTime\n    value:\n        \"@id\": schema:value\n        \"@type\": schema:Number\n</code></pre>"},{"location":"advanced/semantic-web-linked-data/#proxy-to-the-semantic-web","title":"Proxy to the Semantic Web","text":"<p>Spatial data engineers are generally challenged when importing and visualizing fragments of the semantic web. The number of spatial  clients currently supporting SQARQL interaction is limited and requires expert knowledge to use.  A group within the pygeoapi community aims to facilitate semantic web access for spatial data engineers by introducing pygeoapi as a proxy  between the typical GIS clients and the semantic web.</p> <p>A new feature is being prepared which introduces a SPARQL provider to pygeoapi.  The provider enables to browse the results of a SPARQL query as an OGC API - Features collection.</p>"},{"location":"advanced/semantic-web-linked-data/#summary","title":"Summary","text":"<p>Congratulations! You can now configure pygeoapi configurations with linked data concepts.</p>"},{"location":"advanced/seo/","title":"Search Engine Optimization (SEO)","text":"<p>OGC API - Features adopted the Spatial Data on the Web Best Practice 2: Make your spatial data indexable by search engines with the recommendation to include HTML as an output format of any OGC API. It means that users can navigate an OGC API from within their browser and Search Engines are able to crawl the content.</p> <p>An aspect to consider is that, since the API becomes a webpage, common practices for web architecture and development become relevant:</p> <ul> <li>does the website have a clear navigation?</li> <li>is a company logo, branding, privacy statement, cookie warning included?</li> <li>is the webpage WCAG accessable?</li> </ul> <p>Tip</p> <p>Notice that the pygeoapi configuration also has an option to disable HTML output. In that scenario, only the JSON output is available.</p> <p>On the Web, websites are typically visited by web crawlers of popular search engines. Crawlers are automated processes which aid in building the index of the search engine. Crawlers follow links on the Web to identify new or updated content. Cross linking your API to other resources therefore increases the visibility (and ranking) of your API.</p> <p>The British Geo6 wrote an extensive best practice on SEO for data publishers which offers a good overview of SEO in the scope of data publications.</p>"},{"location":"advanced/seo/#tweaking-web-crawler-behaviour","title":"Tweaking Web Crawler behaviour","text":"<p>This paragraph introduces you to some mechanisms which facilitate or block web crawlers to index your content.</p> <p>If you are not interested in having your content indexed by search engines, you can provide a robots.txt file at the root of your website, specifying which folders should not be indexed. More drastically is the option to block access for crawlers or bots to your content by filtering traffic to the website based on the HTTP User-Agent header. Such a rule can be added to a firewall or web server configuration.</p> <p>A <code>robots.txt</code> file can also include a link to a Sitemap. Many search engines provide the option to submit a sitemap in order to speed up crawling and indexing. pygeoapi does not provide a sitemap of its content, but you can create your own sitemap (publish as <code>/sitemap.xml</code>), specifying URLs of your desired content to be indexed.</p> <p>Search engines provide tooling to evaluate the search behaviour of your website. These tools can provide valuable insight in the findability of your website and content (e.g. keywords used to locate your website).</p>"},{"location":"advanced/seo/#schemaorgdataset","title":"Schema.org/Dataset","text":"<p>Search engines cooperate in the Schema.org initiative. Schema.org enables you to annotate your website using the <code>schema.org</code> vocabulaire, in order for search engines to index the content in a structured manner. Google was the first to employ these annotations to provide a dedicated search engine for datasets. pygeoapi adds <code>schema.org/Dataset</code> annotations to collection pages, so collections are automagically included in Google's dataset search.</p> <p>Evaluate the schema.org annotations in collections</p> <p>Google provides a tool to evaluate <code>Schema.org</code> annotation in websites. Try evaluating a collection endpoint of pygeoapi in the tool. If you run pygeoapi locally (not accessible to google), you can copy the source of a page as HTML into the <code>&lt;code&gt;</code> tab, otherwise you can paste the URL of the page in the <code>URL</code> tab.</p> <p>Note</p> <p>A similar tool is made available by Yandex (note that registration is required).</p>"},{"location":"advanced/ui-custom-templates/","title":"UI customization and templating","text":"<p>pygeoapi adopted the Jinja2 templating mechanism to style HTML output. Each element visualized on the HTML output is customizable by overriding the relevant template. Templates are located in the <code>pygeoapi/templates</code> folder. It is possible to override any template by copying it into a separate folder and adjust it to your needs. In the pygeoapi configuration you can then indicate the path to the override folder. Notice that for files which are not placed in the override folder, the original file is used.</p> <p>Caution</p> <p>For any customization, mind that with a new version of pygeoapi changes on the default templates are not automatically available on the overriden files. Upgrades need to be carefully tested and validated.</p>"},{"location":"advanced/ui-custom-templates/#jinja2","title":"Jinja2","text":"<p>Jinja2 is a common templating concept in the Python community. With a minimal background in HTML you will be able to make minor but meaningful customizations. At the core of pygeoapi's template setup is the <code>_base.html</code> template, which defines the header and footer of the page. The fragment below defines the footer of the page, notice the parameters in curly braces, which are replaced by dynamic content. </p> <pre><code> &lt;footer class=\"sticky\"&gt;\n    {% trans %}Powered by {% endtrans %} \n    &lt;a title=\"pygeoapi\" href=\"https://pygeoapi.io\"&gt;\n        &lt;img src=\"{{ config['server']['url'] }}/assets/images/pygeoapi.png\" title=\"pygeoapi logo\" style=\"height:24px;vertical-align: middle;\"/&gt;&lt;/a&gt; \n    {{ version }}\n&lt;/footer&gt;\n</code></pre> <p>Customizing an HTML page</p> <p>Copy <code>_base.html</code> to a separate folder. Adjust some elements on that page (e.g. logo image). Then, include a reference to the new folder in the pygeoapi configuration. Restart the service. Verify the result.</p>"},{"location":"advanced/ui-custom-templates/#css-customizations","title":"CSS customizations","text":"<p>From the customized HTML template you can reference a new stylesheet file with customizations or directly add your customizations to /static/css/default.css.</p>"},{"location":"advanced/ui-custom-templates/#summary","title":"Summary","text":"<p>Congratulations! You've added a custom look and feel to your pygeoapi deployment.</p>"},{"location":"publishing/","title":"Publishing Data","text":"<p>Note</p> <p>Ensure that you have pygeoapi setup and can navigate the default configuration and service running at http://localhost:5000.</p> <p>In this section, you will learn how to publish different types of geospatial data and metadata through the following exercises:</p> <ul> <li>Exercise 1 - Your first dataset</li> <li>Exercise 2 - Vector data via OGC API - Features</li> <li>Exercise 3 - Raster data via OGC API - Coverages</li> <li>Exercise 4 - Tiles of geospatial data via OGC API - Tiles</li> <li>Exercise 5 - Maps of geospatial data via OGC API - Maps</li> <li>Exercise 6 - Metadata via OGC API - Records</li> <li>Exercise 7 - Environmental data via OGC API - Environmental Data Retrieval</li> <li>Exercise 8 - Functions via OGC API - Processes</li> <li>Exercise 9 - pygeoapi as a bridge to other services</li> </ul>"},{"location":"publishing/first/","title":"Exercise 1 - Your first dataset","text":"<p>In this section you are going to publish a vector dataset.</p> <p>For this exercise, we will use a CSV dataset of Bathing waters in Estonia, kindly provided by Estonian Health Board.</p> <p>You can find this dataset in <code>workshop/exercises/data/bathingwater-estonia.csv</code>.</p> <p>This exercise consists of two steps:</p> <ul> <li>adjust <code>workshop/exercises/pygeoapi.config.yml</code> to define this dataset as an OGC API - Features collection</li> <li>ensure that pygeoapi can find and connect to the data file</li> </ul> <p>We will use the <code>workshop/exercises/docker-compose.yml</code> file provided.</p>"},{"location":"publishing/first/#verify-the-existing-docker-compose-config","title":"Verify the existing Docker Compose config","text":"<p>Before making any changes, we will make sure that the initial Docker Compose setup provided to you is actually working. Two files are relevant:</p> <ul> <li><code>workshop/exercises/docker-compose.yml</code></li> <li><code>workshop/exercises/pygeoapi.config.yml</code></li> </ul> <p>To test:</p> <p>Test the workshop configuration</p> <ol> <li>In a terminal shell navigate to the workshop folder and type:</li> </ol> <p> <pre><code>cd workshop/exercises\ndocker-compose up\n</code></pre>  1. Open http://localhost:5000 in your browser, verify some collections 1. Close by typing <code>CTRL-C</code></p> <p>Note</p> <p>You may also run the Docker container in the background (detached) as follows:</p> <p> <pre><code>docker-compose up -d\ndocker ls  # verify that the pygeoapi container is running\n# visit http://localhost:5000 in your browser, verify some collections\ndocker logs --follow pygeoapi  # view logs\ndocker-compose stop\n</code></pre> </p>"},{"location":"publishing/first/#publish-first-dataset","title":"Publish first dataset","text":"<p>You are now ready to publish your first dataset.</p> <p>Setting up the pygeoapi config file</p> <ol> <li>Open the file <code>workshop/exercises/pygeoapi/pygeoapi.config.yml</code> in your text editor</li> <li>Look for the commented config section starting with <code># START - EXERCISE 1 - Your First Collection</code></li> <li>Uncomment all lines until <code># END - EXERCISE 1 - Your First Collection</code></li> </ol> <p>Make sure that the indentation aligns (hint: directly under <code># START ...</code>)</p> <p>The config section reads:</p> <pre><code>    Bathing_Water_Estonia:\n        type: collection\n        title: Bathing Water Estonia\n        description: Locations where the Estonian Health Board monitors the bathing water quality\n        keywords:\n            - bathing water\n            - estonia\n        links:\n            - type: text/csv\n              rel: canonical\n              title: data\n              href: https://avaandmed.eesti.ee/datasets/joogiveeallikad\n              hreflang: EE\n        extents:\n            spatial:\n                bbox: [20,57,29,60]\n                crs: http://www.opengis.net/def/crs/EPSG/0/4326\n        providers:\n            - type: feature\n              name: CSV\n              data: /data/bathingwater-estonia.csv\n              id_field: id\n              title_field: Name\n              geometry:\n                x_field: x\n                y_field: y\n              storage_crs: http://www.opengis.net/def/crs/EPSG/0/3300\n</code></pre> <p>The most relevant part is the <code>providers</code> section. Here, we define a <code>CSV Provider</code>, pointing the file path to the <code>/data</code> directory we will mount (see next) from the local directory into the Docker container above. Because a CSV is not a spatial file, we explicitly configure pygeoapi so that the longitude and latitude (x and y) is mapped from the columns <code>lon</code> and <code>lat</code> in the CSV file. Notice the <code>storage_crs</code> parameter, which indicates the coordinate system which is used in the source data.</p> <p>Tip</p> <p>To learn more about the pygeoapi configuration syntax and conventions see the relevant chapter in the documentation.</p> <p>Tip</p> <p>pygeoapi includes numerous data providers which enable access to a variety of data formats. Via the OGR/GDAL plugin the number of supported formats is almost limitless. Consult the data provider page how you can set up a connection to your dataset of choice. You can always copy a relevant example configuration and place it in the datasets section of the pygeoapi configuration file for your future project.</p>"},{"location":"publishing/first/#making-data-available-in-the-docker-container","title":"Making data available in the Docker container","text":"<p>As the Docker container (named <code>pygeoapi</code>) cannot directly access files on your local host system, we will use Docker volume mounts. This can be defined  in the <code>docker-compose.yml</code> file as follows:</p> <p>Configure access to the data</p> <ol> <li>Open the file <code>workshop/exercises/docker-compose.yml</code></li> <li>Look for the commented section <code># Exercise 1 -</code></li> <li>Uncomment that line  <code>- ./data:/data</code></li> </ol> <p>The relevant lines read:</p> <pre><code>volumes:\n    - ./pygeoapi/pygeoapi.config.yml:/pygeoapi/local.config.yml\n    - ./data:/data # Exercise 1 - Ready to pull data from here\n</code></pre> <p>The local <code>./pygeoapi/pygeoapi.config.yml</code> file was already mounted. Now we have also mounted (made available) the entire local directory <code>./data</code>.</p>"},{"location":"publishing/first/#test","title":"Test","text":"<p>Start with updated configuration</p> <ol> <li>Start by typing <code>docker-compose up</code> </li> <li>Observe logging output</li> <li>If no errors: open http://localhost:5000</li> <li>Look for the Point of interest collection</li> <li>Browse through the items of the collection</li> <li>Check the json representation by adding ?f=json to url (or click 'json' in top right)</li> </ol>"},{"location":"publishing/first/#debugging-configuration-errors","title":"Debugging configuration errors","text":"<p>Incidentally you may run into errors, briefly discussed here:</p> <ul> <li>A file cannot be found, a typo in the configuration</li> <li>The format or structure of the spatial file is not fully supported</li> <li>The port (5000) is already taken. Is a previous pygeoapi still running? If you change the port, consider that you also have to update the pygeoapi config file</li> </ul> <p>There are two parameters in the configuration file which help to address these issues.  Set the logging level to <code>DEBUG</code> and indicate a path to a log file. </p> <p>Tip</p> <p>On Docker, set the path of the logfile to the mounted folder, so you can easily access it from your host system. You can also view the console logs from your Docker container as follows:</p> <p> <pre><code>docker logs --follow pygeoapi\n</code></pre> </p> <p>Tip</p> <p>Errors related to file paths typically happen on initial setup. However, they may also happen at unexpected moments, resulting in a broken service. Products such as GeoHealthCheck aim to monitor, detect and notify service health and availability. The OGC API - Features tests in GeoHealthCheck poll the availability of the service at intervals. Consult the GeoHealthCheck documentation for more information. </p>"},{"location":"publishing/ogcapi-coverages/","title":"Exercise 3 - Raster data via OGC API - Coverages","text":"<p>OGC API - Coverages provides a Web API to access raster data (grids, remote sensing data, multidimensional data cubes):</p> <ul> <li>OGC API - Coverages (draft)</li> </ul>"},{"location":"publishing/ogcapi-coverages/#pygeoapi-support","title":"pygeoapi support","text":"<p>pygeoapi supports the OGC API - Coverages draft specification, with rasterio and xarray as core backends as well as CoverageJSON and native output.</p> <p>Note</p> <p>See the official documentation for more information on supported raster backends</p>"},{"location":"publishing/ogcapi-coverages/#publish-a-raster-dataset","title":"Publish a raster dataset","text":"<p>In the previous exercises we have demonstrated the steps involved to publish vector data and update the pygeoapi configuration. In this section we are going to publish a raster file in GeoTIFF format, from a rasterio source provider.</p> <p>Download and unzip the GeoTIFF file:</p> <pre><code>cd workshop/exercises/data\ncurl -O http://dati.cittametropolitana.fi.it/geonetwork/srv/api/records/cmfi:419774cb-e812-4ca4-991d-97f0b747e017/attachments/53.zip\nunzip 53.zip\n</code></pre> <p>If you do not have curl installed, copy the URL above to your web browser and save locally.</p> <p>You can now add <code>53_ED1_G.tif</code> to pygeoapi:</p> <p>Update the pygeoapi configuration</p> <p>Open the pygeoapi configuration file in a text editor. Add a new dataset section as follows:</p> <pre><code>firenze-terrains:\n    type: collection\n    title: Administrative boundaries before 2014\n    description: Cadastral parcels (terrains) from the cadastre. Territory Agency; SIT and Information Networks;\n    keywords:\n        - Cadastral parcels\n    links:\n        - type: text/html\n          rel: canonical\n          title: Administrative boundaries before 2014\n          href: http://dati.cittametropolitana.fi.it/geonetwork/srv/metadata/cmfi:419774cb-e812-4ca4-991d-97f0b747e017\n          hreflang: it\n    extents:\n        spatial:\n            bbox: [10.70,43.43,11.76,44.25]\n            crs: http://www.opengis.net/def/crs/OGC/1.3/CRS84\n    providers:\n        - type: coverage\n          name: rasterio\n          data: /data/53_ED1_G.tif # place correct path here\n          format:\n              name: GTiff\n              mimetype: application/tiff\n</code></pre> <p>Tip</p> <p>The rasterio provider <code>format.name</code> directive requires a valid GDAL raster driver short name</p> <p>Save the configuration and restart Docker Compose. Navigate to http://localhost:5000/collections to evaluate whether the new dataset has been published.</p>"},{"location":"publishing/ogcapi-coverages/#client-access","title":"Client access","text":""},{"location":"publishing/ogcapi-coverages/#gdalogr","title":"GDAL/OGR","text":"<p>GDAL/OGR provides support for OGC API - Coverages. This means you can use <code>gdalinfo</code> to query and convert data from OGC API - Coverages endpoints just like any other raster data source.  This also means you can make connections to OGC API - Coverages endpoints from any software which has an interface to GDAL, such as MapServer, GeoServer, Manifold, FME, ArcGIS, etc.</p> <p>Use GDAL to interact with OGC API - Coverages</p> <ul> <li>Verify you have a recent GDAL installed, else use GDAL from OSGeoLive</li> <li>Run <code>gdalinfo</code> on the command line to verify a connection to OGC API - Coverages:</li> </ul> <p> <pre><code>gdalinfo OGCAPI:https://maps.ecere.com/ogcapi/collections/SRTM_ViewFinderPanorama\n</code></pre> </p>"},{"location":"publishing/ogcapi-coverages/#owslib","title":"OWSLib","text":"<p>OWSLib is a Python library to interact with OGC Web Services and supports a number of OGC APIs including OGC API - Coverages.</p> <p>Interact with OGC API - Coverages via OWSLib</p> <p>If you do not have Python installed, consider running this exercise in a Docker container. See the Setup Chapter. </p> <p> <pre><code>pip3 install owslib\n</code></pre> </p> <p> <pre><code>&gt;&gt;&gt; from owslib.ogcapi.coverages import Coverages\n&gt;&gt;&gt; SERVICE_URL = 'https://demo.pygeoapi.io/master/'\n&gt;&gt;&gt; w = Coverages(SERVICE_URL)\n&gt;&gt;&gt; w.url\n'https://demo.pygeoapi.io/master/'\n&gt;&gt;&gt; gdps = w.collection('gdps-temperature')\n&gt;&gt;&gt; gdps['id']\n'gdps-temperature'\n&gt;&gt;&gt; gdps['title']\n'Global Deterministic Prediction System sample'\n&gt;&gt;&gt; gdps['description']\n'Global Deterministic Prediction System sample'\n&gt;&gt;&gt; schema = w.collection_schema('gdps-temperature')\n&gt;&gt;&gt; len(schema['field'])\n1\n&gt;&gt;&gt; schema['properties']['1']['title']\n'Temperature [C]'\n&gt;&gt;&gt; schema['properties']['1']['x-ogc-unit']\n'[C]'\n&gt;&gt;&gt; schema['properties']['1']['type']\n'number'\n</code></pre> </p> <p>Note</p> <p>See the official OWSLib documentation for more examples.</p>"},{"location":"publishing/ogcapi-coverages/#summary","title":"Summary","text":"<p>Congratulations! You are now able to publish raster data to pygeoapi.</p>"},{"location":"publishing/ogcapi-edr/","title":"Exercise 7 - Environmental data via OGC API - Environmental Data Retrieval","text":"<p>OGC API - Environmental Data Retrieval provides a Web API to access environmental data using well defined query patterns:</p> <ul> <li>OGC API - Environmental Data Retrieval Standard</li> </ul> <p>OGC API - Environmental Data Retrieval uses OGC API - Features as a building block, thus enabling streamlined integration for clients and users.  EDR can be considered a convenience API which does not require in depth knowledge about the underlying data store/model.</p>"},{"location":"publishing/ogcapi-edr/#pygeoapi-support","title":"pygeoapi support","text":"<p>pygeoapi supports the OGC API - Environmental Data Retrieval specification by leveraging both feature and coverage provider plugins.</p> <p>Note</p> <p>See the official documentation for more information on supported EDR backends</p>"},{"location":"publishing/ogcapi-edr/#publish-environmental-data-in-pygeoapi","title":"Publish environmental data in pygeoapi","text":"<p>Let's try publishing some ICOADS data via the EDR xarray plugin. The sample ICOADS data can be found in <code>workshop/exercises/data/coads_sst.nc</code>:</p> <p>Update the pygeoapi configuration</p> <p>Open the pygeoapi configuration file in a text editor. Add a new dataset section as follows:</p> <pre><code>    icoads-sst:\n        type: collection\n        title: International Comprehensive Ocean-Atmosphere Data Set (ICOADS)\n        description: International Comprehensive Ocean-Atmosphere Data Set (ICOADS)\n        keywords:\n            - icoads\n            - sst\n            - air temperature\n        extents:\n            spatial:\n                bbox: [-180,-90,180,90]\n                crs: http://www.opengis.net/def/crs/OGC/1.3/CRS84\n            temporal:\n                begin: 2000-01-16T06:00:00Z\n                end: 2000-12-16T06:00:00Z\n        links:\n            - type: text/html\n              rel: canonical\n              title: information\n              href: https://psl.noaa.gov/data/gridded/data.coads.1deg.html\n              hreflang: en-US\n        providers:\n            - type: edr\n              name: xarray-edr\n              data: /data/coads_sst.nc\n              format:\n                  name: NetCDF\n                  mimetype: application/x-netcdf\n</code></pre> <p>Save the configuration and restart Docker Compose. Navigate to http://localhost:5000/collections to evaluate whether the new dataset has been published.</p> <p>At first glance, the <code>icoads-sst</code> collection appears as a normal OGC API - Coverages collection. Look a bit closer at the collection description, and notice that there is a `parameter_names' key that describes EDR parameter names for the collection queries.</p>"},{"location":"publishing/ogcapi-edr/#owslib-advanced","title":"OWSLib - Advanced","text":"<p>OWSLib is a Python library to interact with OGC Web Services and supports a number of OGC APIs including OGC API - Environmental Data Retrieval.</p> <p>Interact with OGC API - Environmental Data Retrieval via OWSLib</p> <p>If you do not have Python installed, consider running this exercise in a Docker container. See the Setup Chapter.</p> <p> <pre><code>pip3 install owslib\n</code></pre> </p> <p>Then start a Python console session with: <code>python3</code> (stop the session by typing <code>exit()</code>).</p> <p> <pre><code>&gt;&gt;&gt; from owslib.ogcapi.edr import  EnvironmentalDataRetrieval\n&gt;&gt;&gt; w = EnvironmentalDataRetrieval('https://demo.pygeoapi.io/master')\n&gt;&gt;&gt; w.url\n'https://demo.pygeoapi.io/master'\n&gt;&gt;&gt; api = w.api()  # OpenAPI document\n&gt;&gt;&gt; collections = w.collections()\n&gt;&gt;&gt; len(collections['collections'])\n13\n&gt;&gt;&gt; icoads_sst = w.collection('icoads-sst')\n&gt;&gt;&gt; icoads_sst['parameter-names'].keys()\ndict_keys(['SST', 'AIRT', 'UWND', 'VWND'])\n&gt;&gt;&gt; data = w.query_data('icoads_sst', 'position', coords='POINT(-75 45)', parameter_names=['SST', 'AIRT'])\n&gt;&gt;&gt; data  # CoverageJSON data\n</code></pre> </p> <p>Note</p> <p>See the official OWSLib documentation for more examples.</p>"},{"location":"publishing/ogcapi-edr/#summary","title":"Summary","text":"<p>Congratulations!  You are now able to publish environmental data to pygeoapi.</p>"},{"location":"publishing/ogcapi-features/","title":"Exercise 2 - Vector data via OGC API - Features","text":"<p>OGC API - Features provides a Web API to access vector  data (geometries and their attributes). While the core specification covers basic data access and query, additional related standards and extensions are in development for the following capabilities:</p> <ul> <li>OGC API - Features - Part 1: Core provides basic access and query capabilities</li> <li>OGC API - Features - Part 2: Coordinate Reference Systems by Reference enables the import and export of any data according to dedicated projections</li> <li>OGC API - Features - Part 3: Filtering (draft) adds the ability for complex queries using Common Query Language (CQL)</li> <li>OGC API - Features - Part 4: Create, Replace, Update and Delete (draft) adds transactional capabilities</li> </ul>"},{"location":"publishing/ogcapi-features/#pygeoapi-support","title":"pygeoapi support","text":"<p>pygeoapi supports all of the above OGC API - Features specification parts (Part 3 is dependent on backend support i.e. Elasticsearch).</p> <p>Note</p> <p>See the official documentation for more information on supported vector backends</p> <p>Note</p> <p>See the official documentation for more information on CQL support </p> <p>Next, we are going to explore how-to publish vector data using a <code>GeoPackage</code> and a <code>Elasticsearch</code> backend.</p>"},{"location":"publishing/ogcapi-features/#publish-a-geopackage","title":"Publish a GeoPackage","text":"<p>In the previous section we demonstrated the steps involved to add a dataset to pygeoapi and update the configuration.  In this exercise we are going to publish another vector file, this time from a GeoPackage (SQLite3)  data source.</p> <p>Tip</p> <p>It may be helpful to open the dataset in QGIS while adding and updating your pygeoapi server to easily evaluate table attributes, names, spatial properties and CRS.</p> <p>Let's add the file <code>workshop/exercises/data/cp-tartu2.gpkg.zip</code>:</p> <p>Update the pygeoapi configuration</p> <p>First, let's unzip the file cptartu2.gpkg.zip to <code>cptartu2.gpkg</code>.</p> <p>Then, open the pygeoapi configuration file in a text editor. Find the line <code># START - EXERCISE 2 - cadastral parcels Tartu</code>.</p> <p>Add a new dataset section by uncommenting the lines up to <code># END - EXERCISE 2 - cadastral parcels Tartu</code>:</p> <pre><code>cp-tartu:\n    type: collection\n    title: Tartu Cadastral Parcels\n    description: Cadasral parcels in downtown Tartu\n    keywords:\n        - Cadastral parcels\n        - Tartu\n    links:\n        -   type: OGC/WFS\n            rel: canonical\n            title: data\n            href: https://metadata.geoportaal.ee/geonetwork/srv/metadata/9949ec81-f758-42e6-9c1c-6fb604a3f053\n            hreflang: EE\n    extents:\n        spatial:\n            bbox: [26.6, 58.3, 26.8, 58.5]\n            crs: http://www.opengis.net/def/crs/OGC/1.3/CRS84\n    providers:\n        - type: feature\n          name: SQLiteGPKG\n          data: /data/cptartu2.gpkg # place correct path here\n          id_field: nationalca\n          title_field: label\n          table: cptartu2 # table name within gpkg\n</code></pre> <p>Save the file and restart Docker Compose. Navigate to http://localhost:5000/collections to evaluate whether the new dataset with title \"Tartu Cadastral Parcels\" has been published.</p> <p>Note</p> <p>The SQLite driver incidentally has challenges to open the GeoPackage extension on MacOS.  Consult the official documentation  or try with an alternative data format.</p>"},{"location":"publishing/ogcapi-features/#publish-a-geojson-using-elasticsearch","title":"Publish a GeoJSON using Elasticsearch","text":"<p>If you want to explore publishing vector tiles using Elasticsearch clone this fork of pygeoapi:</p> <pre><code>git checkout -b ogcapi-ws https://github.com/doublebyte1/pygeoapi.git\n</code></pre> <p>In alternative, you can download a zip file from this link.</p> <p>Then change into the <code>docker/examples/elastic</code> folder, and run the <code>docker-compose</code> file:</p> <pre><code>cd docker/examples/elastic\n\ndocker-compose up\n</code></pre> <p>This configuration snippet, enables publishing the file <code>greater_hyderabad_municipal_corporation_ward_boundaries.geojson</code> as OGC API - Features:</p> <pre><code>    greater_hyderabad_municipal_corporation_ward_boundaries:\n        type: collection\n        title: Greater Hyderabad Municipal Corporation ward boundaries\n        description: The city ward boundaries represent the administrative and electoral boundary areas of the city. It plays a great role in planning of the city, for each council of the municipal corporation.\n        keywords:\n           - Boundaries\n           - Administrative\n           - Ward\n        links:\n            - type: text/html\n              rel: canonical\n              title: information\n              href: https://livingatlas-dcdev.opendata.arcgis.com/datasets/a090c89d52f1498f96a82e97b8bfb83e_0/about\n              hreflang: en-US\n        extents:\n            spatial:\n                bbox: [78.2379194985166180,17.2908061510471995,78.6217049083810764,17.5618443356918768]\n                crs: http://www.opengis.net/def/crs/OGC/1.3/CRS84\n            temporal:\n                begin: 2011-11-11\n                end: null  # or empty\n        providers:\n            - type: feature\n              name: Elasticsearch\n              # note: elastic_search is the Docker container name as defined in docker-compose.ym\n              data: http://elastic_search:9200/greater_hyderabad_municipal_corporation_ward_boundaries\n              id_field: objectid\n</code></pre> <p>Wait until the data was ingested into an elastic index, and pygeoapi starts. You can check the logs using:</p> <pre><code>docker-compose logs --follow\n</code></pre> <p>After the server has started you can access the collection page here:</p> <p>http://localhost:5000/collections/greater_hyderabad_municipal_corporation_ward_boundaries</p> <p>And the feature items here:</p> <p>http://localhost:5000/collections/greater_hyderabad_municipal_corporation_ward_boundaries/items</p> <p></p>"},{"location":"publishing/ogcapi-features/#pygeoapi-as-a-wfs-proxy","title":"pygeoapi as a WFS proxy","text":"<p>You can check the \"pygeoapi as a Bridge to Other Services\" section to learn how to publish WFS as OGC API - Features.</p>"},{"location":"publishing/ogcapi-features/#client-access","title":"Client access","text":""},{"location":"publishing/ogcapi-features/#qgis","title":"QGIS","text":"<p>QGIS is one of the first GIS Desktop clients which added support for OGC API - Features. Support has been integrated into the existing WFS provider.</p> <p>Open an OGC API - Features collection in QGIS</p> <p>Follow the steps to add some collections from an OGC API - Features enpoint: </p> <ul> <li>Open QGIS (if you don't have QGIS, you can use OSGeoLive)</li> <li>From the Layer menu, select <code>Add Layer</code> &gt; <code>Add WFS layer</code></li> <li>From the <code>Data source manager</code> panel, choose 'New connection'</li> </ul> <p></p> <ul> <li>Add the URL https://demo.pygeoapi.io/master (or the address of a local server)</li> <li>You can now click the <code>detect</code> button and QGIS will notice you are configuring an OGC API - Features endpoint</li> <li>QGIS facilitates to set page size (request is split in multiple requests)<ul> <li>for points you can easily set it to 2500</li> <li>for some polygons with high density, 100 can already be slow</li> </ul> </li> <li>Press <code>OK</code> to save the connection and return to the previous screen</li> <li>Now click the <code>Connect</code> button to retireve the collections of the service</li> </ul> <p></p> <ul> <li>You can now add collections to your QGIS project</li> <li>You can also build a query to add a subset of the collection</li> <li>Close the <code>Data source manager</code>. Notice that QGIS applied a default styling just like it would if you add a file based layer. You can work with the collection in a similar way; identify, apply styling, filter, export, etc.</li> </ul> <p>Tip</p> <p>Activate the <code>Debugging/Development Tools Panel</code> (right click anywhere on the toolbar icons and select). It will display HTTP traffic within QGIS and is a valuable tool in debugging failing connections.</p> <p>Note</p> <p>An increasing number of GIS Desktop clients add support for OGC API's in subsequent releases. For example ArcGIS Pro supports OGC API - Features since release 2.8.</p>"},{"location":"publishing/ogcapi-features/#gdalogr-advanced","title":"GDAL/OGR - Advanced","text":"<p>GDAL/OGR provides support for OGC API - Features. This means you can use <code>ogrinfo</code>, <code>ogr2ogr</code> to query and convert data from OGC API - Features endpoints just like any other vector data source.  This also means you can make connections to OGC API - Features endpoints from any software which has an interface to GDAL, such as MapServer, GeoServer, Manifold, FME, ArcGIS, etc.</p> <p>Use OGR to interact with OGC API - Features</p> <ul> <li>Verify you have a recent GDAL installed, else use GDAL from OSGeoLive</li> <li>Run <code>ogrinfo</code> on the command line to verify a connection to OGC API - Features</li> </ul> <p> <pre><code>ogrinfo OAPIF:https://demo.pygeoapi.io/master/collections/obs\n</code></pre> </p> <p>Now, let's convert the observations into a shapefile</p> <p> <pre><code>ogr2ogr -f \"ESRI Shapefile\" obs.shp OAPIF:https://demo.pygeoapi.io/master/collections/obs\n</code></pre> </p> <p>Note</p> <p>You can even use OGR to append new features to an OGC API - Features collection which supports transactions (pygeoapi transaction support is planned for future implementation)</p>"},{"location":"publishing/ogcapi-features/#owslib-advanced","title":"OWSLib - Advanced","text":"<p>OWSLib is a Python library to interact with OGC Web Services and supports a number of OGC APIs including OGC API - Features.</p> <p>Interact with OGC API - Features via OWSLib</p> <p>If you do not have Python installed, consider running this exercise in a Docker container. See the Setup Chapter.</p> <p> <pre><code>pip3 install owslib\n</code></pre> </p> <p>Then start a Python console session with: <code>python3</code> (stop the session by typing <code>exit()</code>).</p> <p> <pre><code>&gt;&gt;&gt; from owslib.ogcapi.features import Features\n&gt;&gt;&gt; w = Features('https://demo.pygeoapi.io/master')\n&gt;&gt;&gt; w.url\n'https://demo.pygeoapi.io/master'\n&gt;&gt;&gt; conformance = w.conformance()\n{u'conformsTo': [u'http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core', u'http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/oas30', u'http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/html', u'http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/geojson']}\n&gt;&gt;&gt; api = w.api()  # OpenAPI document\n&gt;&gt;&gt; collections = w.collections()\n&gt;&gt;&gt; len(collections['collections'])\n13\n&gt;&gt;&gt; feature_collections = w.feature_collections()\n&gt;&gt;&gt; len(feature_collections)\n13\n&gt;&gt;&gt; lakes = w.collection('lakes')\n&gt;&gt;&gt; lakes['id']\n'lakes'\n&gt;&gt;&gt; lakes['title']\n'Large Lakes'\n&gt;&gt;&gt; lakes['description']\n'lakes of the world, public domain'\n&gt;&gt;&gt; lakes_queryables = w.collection_queryables('lakes')\n&gt;&gt;&gt; len(lakes_queryables['properties'])\n6\n&gt;&gt;&gt; lakes_query = w.collection_items('lakes')\n&gt;&gt;&gt; lakes_query['features'][0]['properties']\n{u'scalerank': 0, u'name_alt': None, u'admin': None, u'featureclass': u'Lake', u'id': 0, u'name': u'Lake Baikal'}\n</code></pre> </p> <p>Note</p> <p>See the official OWSLib documentation for more examples.</p>"},{"location":"publishing/ogcapi-features/#summary","title":"Summary","text":"<p>Congratulations! You are now able to publish vector data to pygeoapi.</p>"},{"location":"publishing/ogcapi-maps/","title":"Exercise 5 - Maps of geospatial data via OGC API - Maps","text":"<p>OGC API - Maps provides a Web API to access any geospatial data as a georeferenced map image.</p> <ul> <li>OGC API - Maps (draft)</li> </ul>"},{"location":"publishing/ogcapi-maps/#pygeoapi-support","title":"pygeoapi support","text":"<p>pygeoapi supports the OGC API - Maps draft specification, using MapServer MapScript and a WMS facade as core backends.</p>"},{"location":"publishing/ogcapi-maps/#publish-a-raster-dataset","title":"Publish a raster dataset","text":"<p>In this section we'll be exposing a Geopackage file available at <code>workshop/exercises/data/airport.gpkg</code> location using MapServer MapScript. This data can be consumed with various clients which are compliant with OGC APIs - Maps. List of few such clients can be found here. Here we can also pass style in .sld format. Which can be generated on Geoserver, QGIS, etc. </p> <p>Interact with OGC API - Maps via MapScript</p> <p>Open the pygeoapi configuration file in a text editor. Find the line <code># START - EXERCISE 5 - Maps</code>.</p> <p>Uncomment section related to #airports.</p> <pre><code>airports:\n    type: collection\n    title: airports of the world\n    description: Point data representing airports around the world with various metadata such as name, Code, etc.\n    keywords:\n        - airports\n        - natural earth\n    links:\n        - type: text/html\n          rel: canonical\n          title: information\n          href: https://www.naturalearthdata.com/downloads/10m-cultural-vectors/airports/\n          hreflang: en-US\n    extents:\n        spatial:\n            bbox: [-180,-90,180,90]\n            crs: http://www.opengis.net/def/crs/OGC/1.3/CRS84\n        temporal:\n            begin:\n            end: null  # or empty\n    providers:\n        - type: map\n          name: MapScript\n          data: /data/airport.gpkg\n          options:\n              type: MS_LAYER_POINT\n              layer: airport\n              style: /data/airport.sld\n          format:\n              name: png\n              mimetype: image/png\n</code></pre> <p>Note</p> <p>See the official documentation for more information on supported map backends</p>"},{"location":"publishing/ogcapi-maps/#pygeoapi-as-a-wms-proxy","title":"pygeoapi as a WMS proxy","text":"<p>You can check the \"pygeoapi as a Bridge to Other Services\" section to learn how to publish WMS as OGC API - Maps.</p>"},{"location":"publishing/ogcapi-maps/#client-access","title":"Client access","text":""},{"location":"publishing/ogcapi-maps/#owslib","title":"OWSLib","text":"<p>OWSLib is a Python library to interact with OGC Web Services and supports a number of OGC APIs including OGC API - Maps.</p> <p>Interact with OGC API - Maps via OWSLib</p> <p>If you do not have Python installed, consider running this exercise in a Docker container. See the Setup Chapter.</p> <p> <pre><code>pip3 install owslib\n</code></pre> </p> <p> <pre><code>&gt;&gt;&gt; from owslib.ogcapi.maps import Maps\n&gt;&gt;&gt; m = Maps('http://localhost:5000')\n&gt;&gt;&gt; data = m.map('wms-facade-demo', width=1200, height=800, transparent=False)\n&gt;&gt;&gt; with open(\"output.png\", \"wb\") as fh:\n...     fh.write(data.getbuffer())\n</code></pre> </p> <p>Note</p> <p>See the official OWSLib documentation for more examples.</p>"},{"location":"publishing/ogcapi-maps/#summary","title":"Summary","text":"<p>Congratulations! You are now able to serve an OGC WMS via pygeoapi and OGC API - Maps.</p>"},{"location":"publishing/ogcapi-processes/","title":"Exercise 8 - Functions via OGC API - Processes","text":"<p>OGC API - Processes supports the wrapping of computational tasks into executable processes that can be offered by a server through a Web API and be invoked by a client application.</p> <ul> <li>OGC API - Processes: Part 1: Core</li> </ul> <p>OGC API - Processes uses OGC API - Common as a building block, thus enabling streamlined deployment and integration for clients and users.</p>"},{"location":"publishing/ogcapi-processes/#pygeoapi-support","title":"pygeoapi support","text":"<p>pygeoapi supports the OGC API - Processes specification, with the ability to publish Python code (no matter how simple or complex) as an OGC API Process definition.  pygeoapi also support synchronous or asynchronous processing, with the ability to store and retrive the status/results of 'jobs'.</p> <p>Note</p> <p>See the official documentation for more information on publishing processes in pygeoapi</p>"},{"location":"publishing/ogcapi-processes/#publishing-python-code-as-a-process-in-pygeoapi","title":"Publishing Python code as a process in pygeoapi","text":"<p>With pygeoapi we can setup OGC API - Processes using Python code that implements the pygeoapi <code>BaseProcessor</code>, which is a core pygeoapi abstract base class.  In this exercise we will implemented a \"squared\" function as a process using the sample Python code in <code>workshop/exercises/plugins/process/squared.py</code>.  The process is already defined to be part of the pygeoapi environment and configuration.</p> <p>Update the pygeoapi configuration</p> <p>Open the pygeoapi configuration file in a text editor. Add a new process section as follows:</p> <pre><code>    squared:\n        type: process\n        processor:\n            name: pygeoapi.process.squared.SquaredProcessor\n</code></pre> <p>Update Python code</p> <p>Open the Python code at <code>workshop/exercises/plugins/process/squared.py</code>.  Find the <code>execute</code> function and update the Python code to calculate the input value squared.</p> <p>Save the configuration and restart Docker Compose. Navigate to http://localhost:5000/processes to evaluate whether the new process has been published.  Inspect the detailed process metadata by navigating to http://localhost:5000/processes/squared to inspect how the process metadata defined in the Python code/file is made available in JSON..</p>"},{"location":"publishing/ogcapi-processes/#client-access","title":"Client access","text":""},{"location":"publishing/ogcapi-processes/#swagger","title":"Swagger","text":"<p>The easiest way to test the new process is by using pygeoapi's built in Swagger interface.  Navigate to http://localhost:5000/openapi and try out the process in the Swagger UI.</p> <p></p> <p></p> <p></p>"},{"location":"publishing/ogcapi-processes/#summary","title":"Summary","text":"<p>Congratulations!  You are now able to publish Python code as a process to pygeoapi.</p>"},{"location":"publishing/ogcapi-records/","title":"Exercise 6 - Metadata via OGC API - Records","text":"<p>OGC API - Records provides a Web API with the capability to create, modify, and query metadata on the Web:</p> <ul> <li>OGC API - Records: Part 1: Core (draft)</li> </ul> <p>OGC API - Records uses OGC API - Features as a building block, thus enabling streamlined deployment and integration for clients and users.</p>"},{"location":"publishing/ogcapi-records/#pygeoapi-support","title":"pygeoapi support","text":"<p>pygeoapi supports the OGC API - Records draft specification, using Elasticsearch and TinyDB rasterio as core backends.</p> <p>Note</p> <p>See the official documentation for more information on supported catalogue/metadata backends</p>"},{"location":"publishing/ogcapi-records/#publish-metadata-records-in-pygeoapi","title":"Publish metadata records in pygeoapi","text":"<p>With pygeoapi we can setup OGC API - Records using any supported data provider. In this exercise we will use the TinyDB Catalogue backend. We will use the sample catalogue in <code>workshop/exercises/data/records/catalogue.tinydb</code>.</p> <p>Update the pygeoapi configuration</p> <p>Open the pygeoapi configuration file in a text editor. Add a new dataset section as follows:</p> <pre><code>    example_catalogue:\n        type: collection\n        title: FOSS4G Florence Record catalogue\n        description: FOSS4G Florence Record catalogue (OGC API - Records)\n        keywords:\n            - Services\n            - Infrastructures\n            - Florence\n            - FOSS4G\n        links:\n            - type: text/html\n              rel: canonical\n              title: information\n              href: http://opendata.comune.firenze.it\n              hreflang: en-US\n        extents:\n            spatial:\n                bbox: [11.145, 43.718, 11.348, 43.84]\n                crs: http://www.opengis.net/def/crs/OGC/1.3/CRS84\n        providers:\n            - type: record\n              name: TinyDBCatalogue\n              data: /data/records/catalogue.tinydb\n              id_field: externalId\n              time_field: recordCreated\n              title_field: title\n</code></pre> <p>Save the configuration and restart Docker Compose. Navigate to http://localhost:5000/collections to evaluate whether the new dataset has been published.</p>"},{"location":"publishing/ogcapi-records/#metadata-formats","title":"Metadata formats","text":"<p>By default, pygeoapi supports and expects the OGC API - Records core record model and queryables. For additional metadata formats, you can develop your own custom pygeoapi plugin, or convert your metadata to OGC API - Records core record model before adding to pygeoapi.</p> <p>Install OWSLib</p> <p>If you do not have Python installed, consider running this exercise in a Docker container. See the Setup Chapter.</p> <p> <pre><code>pip3 install owslib\n</code></pre> </p>"},{"location":"publishing/ogcapi-records/#sample-iso-19139-to-tinydbcatalogue-loader","title":"Sample ISO 19139 to TinyDBCatalogue loader","text":"<p>It is possible to load more example ISO19139 metadata in a TinyDB database with the following script (raw):</p> <pre><code>cd workshop/exercises/data/records\ncurl -O https://raw.githubusercontent.com/geopython/pygeoapi/master/tests/load_tinydb_records.py\npython3 load_tinydb_records.py xml catalogue.tinydb\n</code></pre> <p>If you do not have curl installed, copy the URL above to your web browser and save locally.</p> <p>If you do not have Python installed, you can the loader by using the OWSLib Docker container. See the Setup Chapter.</p> <p>Using the OWSLib Docker container to load metadata</p> Linux/MacWindows <p> <pre><code>cd workshop/exercises\ndocker run -it --rm --network=host --name owslib -v $(pwd)/data:/data python:3.10-slim /bin/bash\npip3 install owslib\napt-get update -y &amp;&amp; apt-get install curl -y\ncurl -O https://raw.githubusercontent.com/geopython/pygeoapi/master/tests/load_tinydb_records.py\npython3 load_tinydb_records.py /data/records/xml /data/records/catalogue.tinydb\n</code></pre> </p> <p> <pre><code>cd workshop/exercises\ndocker run -it --rm --network=host --name owslib -v $(pwd)/data:/data python:3.10-slim /bin/bash\npip3 install owslib\napt-get update -y &amp;&amp; apt-get install curl -y\ncurl -O https://raw.githubusercontent.com/geopython/pygeoapi/master/tests/load_tinydb_records.py\npython3 load_tinydb_records.py /data/records/xml /data/records/catalogue.tinydb\n</code></pre> </p> <p>Navigate to http://localhost:5000/collections/example_catalogue to evaluate whether the new metadata has been published to the collection.</p> <p>Tip</p> <p>pygeometa is a Python package to generate metadata for geospatial datasets.  pygeometa allows for managing metadata in simple YAML \"metadata control files (MCF), and supports import, export as well as transformations for many geospatial metadata formats.  OGC API - Records metadata can be produced using pygeometa, either from MCF files or transforming from other formats.</p> <p>Install and run pygeometa per below to get an idea of the various commands and functionality (as well, consult the tutorial).</p> <p> <pre><code>pip3 install pygeometa\npygeometa --help\n</code></pre> </p>"},{"location":"publishing/ogcapi-records/#pygeoapi-as-a-csw-proxy","title":"pygeoapi as a CSW proxy","text":"<p>You can check the \"pygeoapi as a Bridge to Other Services\" section to learn how to publish CSW as OGC API - Records.</p>"},{"location":"publishing/ogcapi-records/#client-access","title":"Client access","text":""},{"location":"publishing/ogcapi-records/#qgis","title":"QGIS","text":"<p>QGIS supports OGC API - Records via the MetaSearch plugin. MetaSearch originally focused on Catalogue Service for the Web (OGC:CSW) only, but has been extended to OGC API - Records. MetaSearch is a default plugin in QGIS and requires no further installation.</p> <p>Query OGC API - Records from QGIS</p> <p>Follow these steps to connect to a service and query datasets:</p> <ul> <li>Locate the MetaSearch plugin in the Web menu or on the Toolbar . The main search panel will appear with the default MetaSearch catalogue list already populated.</li> </ul> <p></p> <ul> <li>open the <code>Services</code> tab, to find the <code>New</code> button to create a new connection</li> <li>add a connection to <code>https://demo.pygeoapi.io/master</code></li> <li>click <code>Service Info</code> to get information about the service</li> <li>return to the Search tab</li> <li>select the connection you have just created</li> <li>type a search term and click <code>search</code></li> <li>notice that when you select a search result, a red footprint is drawn on the map highlighting the location of the dataset</li> </ul> <p></p> <p>OWSLib is a Python library to interact with OGC Web Services and supports a number of OGC APIs including OGC API - Records.</p> <p>Interact with OGC API - Records via OWSLib</p> <p>If you do not have Python installed, consider running this exercise in a Docker container. See the Setup Chapter.</p> <p> <pre><code>pip3 install owslib\n</code></pre> </p> <p>Then start a Python console session with: <code>python3</code> (stop the session by typing <code>exit()</code>).</p> <p> <pre><code>&gt;&gt;&gt; from owslib.ogcapi.records import Records\n&gt;&gt;&gt; SERVICE_URL = 'https://demo.pygeoapi.io/master/'\n&gt;&gt;&gt; w = Records(SERVICE_URL)\n&gt;&gt;&gt; w.url\n'https://demo.pygeoapi.io/master'\n&gt;&gt;&gt; dutch_metacat = w.collection('dutch-metadata')\n&gt;&gt;&gt; dutch_metacat['id']\n'dutch-metadata'\n&gt;&gt;&gt; dutch_metacat['title']\n'Sample metadata records from Dutch Nationaal georegister'\n&gt;&gt;&gt; dutch_metacat['description']\n'Sample metadata records from Dutch Nationaal georegister'\n&gt;&gt;&gt; dutch_metacat_query = w.collection_items('dutch-metadata', limit=1)\n&gt;&gt;&gt; dutch_metacat_query['numberMatched']\n198\n&gt;&gt;&gt; dutch_metacat_query['numberReturned']\n1\n&gt;&gt;&gt; dutch_metacat_query = w.collection_items('dutch-metadata', q='Wegpanorama')\n&gt;&gt;&gt; dutch_metacat_query['numberMatched']\n2\n</code></pre> </p> <p>Note</p> <p>See the official OWSLib documentation for more examples.</p>"},{"location":"publishing/ogcapi-records/#summary","title":"Summary","text":"<p>Congratulations!  You are now able to publish metadata to pygeoapi.</p>"},{"location":"publishing/ogcapi-tiles/","title":"Exercise 4 - Tiles of geospatial data via OGC API - Tiles","text":"<p>OGC API - Tiles provides a Web API to deliver tiles of geospatial information. Different forms of geospatial information are supported, such as tiles of vector features (\"vector tiles\"), coverages, maps (or imagery) and potentially eventually additional types of tiles of geospatial information. The standard is available on this document:</p> <ul> <li>OGC API - Tiles: Part 1: Core</li> </ul> <p>Note</p> <p>OGC API - Tiles extends the <code>collections/*</code> URL structure (tilesets are listed under <code>/collections/example/tiles</code>:</p> <pre><code>https://demo.pygeoapi.io/collections/lakes/tiles/WorldCRS84Quad/{tileMatrix}/{tileRow}/{tileCol}?f=mvt\n</code></pre>"},{"location":"publishing/ogcapi-tiles/#pygeoapi-support","title":"pygeoapi support","text":"<p>pygeoapi supports the core OGC API - Tiles specification, and is able to advertise an existing tileset. Note that pygeoapi itself does not render tiles from source data. It supports publishing pre-rendered tiles from a static url or from a tile server with a <code>xyz</code> url template.</p> <p>Note</p> <p>The OGC API - Tiles URL structure is compatible with XYZ layers in common libraries such as OpenLayers, Leaflet and MapML</p> <p>Note</p> <p>See the official documentation for more information on supported tile backends</p>"},{"location":"publishing/ogcapi-tiles/#publish-pre-rendered-vector-tiles","title":"Publish pre-rendered vector tiles","text":"<p>In this scenario, tiles must be pre-rendered before serving. Existing tools to create tiles include, but are not limited to:</p> <ul> <li>TileMill</li> <li>MapProxy</li> <li>QGIS</li> <li>tippecanoe</li> </ul> <p>For this exercise, you will publish a vector dataset of the greater Hyderabad municipal corporation ward boundaries, from the location below:</p> <ul> <li>data: <code>workshop/exercises/data/greater_hyderabad_municipal_corporation_ward_Boundaries.geojson</code></li> </ul> <p>Let's generate the tiles as the first step using tippecanoe:</p> <p>Using tippecanoe to generate vector tiles</p> Linux/MacWindows <p> <pre><code>cd workshop/exercises\ndocker run -it --rm -v $(pwd)/data:/data emotionalcities/tippecanoe \\\ntippecanoe --output-to-directory=/data/tiles/ --force --maximum-zoom=16 --drop-densest-as-needed --extend-zooms-if-still-dropping --no-tile-compression /data/greater_hyderabad_municipal_corporation_ward_Boundaries.geojson\n</code></pre> </p> <p> <pre><code>cd workshop/exercises\ndocker run -it --rm -v ${pwd}/data:/data emotionalcities/tippecanoe tippecanoe --output-to-directory=/data/tiles/ --force --maximum-zoom=16 --drop-densest-as-needed --extend-zooms-if-still-dropping --no-tile-compression /data/greater_hyderabad_municipal_corporation_ward_Boundaries.geojson\n</code></pre> </p> <p>Update the pygeoapi configuration</p> <p>Open the pygeoapi configuration in a text editor. Add a new dataset section as follows:</p> <pre><code>    hyderabad:\n        type: collection\n        title: Greater Hyderabad Municipal Corporation ward boundaries\n        description: The city ward boundaries represent the administrative and electoral boundary areas of the city. It plays a great role in planning of the city, for each council of the municipal corporation.\n        keywords:\n           - Boundaries\n           - Administrative\n           - Ward\n        links:\n            - type: text/html\n              rel: canonical\n              title: information\n              href: https://livingatlas-dcdev.opendata.arcgis.com/datasets/a090c89d52f1498f96a82e97b8bfb83e_0/about\n              hreflang: en-US\n        extents:\n            spatial:\n                bbox: [78.2379194985166180,17.2908061510471995,78.6217049083810764,17.5618443356918768]\n                crs: http://www.opengis.net/def/crs/OGC/1.3/CRS84\n            temporal:\n                begin: 2011-11-11\n                end: null  # or empty\n        providers:\n            - type: feature\n              name: GeoJSON\n              data: /data/greater_hyderabad_municipal_corporation_ward_Boundaries.geojson\n              id_field: objectid\n            - type: tile\n              name: MVT\n              data: /data/tiles\n              options:\n                metadata_format: tilejson # default | tilejson\n                zoom:\n                    min: 0\n                    max: 16\n                schemes:\n                    - WorldCRS84Quad\n              format:\n                    name: pbf\n                    mimetype: application/vnd.mapbox-vector-tile\n</code></pre> <p>Save the file and restart Docker Compose. Navigate to http://localhost:5000/collections to evaluate whether the new dataset has been published.</p> <p>Additional check for the following tile specific endpoints in the <code>Hyderabad</code> collection:</p> <ul> <li>tile links in http://localhost:5000/collections/hyderabad/tiles</li> <li>tile metadata in http://localhost:5000/collections/hyderabad/tiles/WorldCRS84Quad/metadata</li> </ul> <p></p>"},{"location":"publishing/ogcapi-tiles/#publish-vector-tiles-from-elasticsearch","title":"Publish vector tiles from Elasticsearch","text":"<p>Elasticsearch provides a middleware that renders an index on the fly, as vector tiles. This middleware is also supported by the pygeoapi mvt backend.</p> <p>If you want to explore publishing vector tiles using Elasticsearch clone this fork of pygeoapi:</p> <pre><code>git checkout -b ogcapi-ws https://github.com/doublebyte1/pygeoapi.git\n</code></pre> <p>Then change into the <code>docker/examples/elastic</code> folder, and run the <code>docker-compose</code> file:</p> <pre><code>cd docker/examples/elastic\n\ndocker-compose up\n</code></pre> <p>This configuration, enables publishing greater_hyderabad_municipal_corporation_ward_boundaries.geojson as both OGC API - Features and OGC API - Tiles:</p> <pre><code>    greater_hyderabad_municipal_corporation_ward_boundaries:\n        type: collection\n        title: Greater Hyderabad Municipal Corporation ward boundaries\n        description: The city ward boundaries represent the administrative and electoral boundary areas of the city. It plays a great role in planning of the city, for each council of the municipal corporation.\n        keywords:\n           - Boundaries\n           - Administrative\n           - Ward\n        links:\n            - type: text/html\n              rel: canonical\n              title: information\n              href: https://livingatlas-dcdev.opendata.arcgis.com/datasets/a090c89d52f1498f96a82e97b8bfb83e_0/about\n              hreflang: en-US\n        extents:\n            spatial:\n                bbox: [78.2379194985166180,17.2908061510471995,78.6217049083810764,17.5618443356918768]\n                crs: http://www.opengis.net/def/crs/OGC/1.3/CRS84\n            temporal:\n                begin: 2011-11-11\n                end: null  # or empty\n        providers:\n            - type: feature\n              name: Elasticsearch\n              # note: elastic_search is the Docker container name as defined in docker-compose.yml\n              data: http://elastic_search:9200/greater_hyderabad_municipal_corporation_ward_boundaries\n              id_field: objectid\n            - type: tile\n              name: MVT\n              data: http://elastic_search:9200/greater_hyderabad_municipal_corporation_ward_boundaries/_mvt/geometry/{z}/{x}/{y}?grid_precision=0\n              # index must have a geo_point\n              options:\n                metadata_format: none # default | tilejson\n                zoom:\n                    min: 0\n                    max: 16\n                schemes:\n                    - WorldCRS84Quad\n              format:\n                    name: pbf\n                    mimetype: application/vnd.mapbox-vector-tile\n</code></pre>"},{"location":"publishing/ogcapi-tiles/#client-access","title":"Client access","text":""},{"location":"publishing/ogcapi-tiles/#qgis","title":"QGIS","text":"<p>QGIS supports OGC API Vector Tiles via the Vector Tiles Layer. Although OGC API - Tiles are not natively supported, you can customize the <code>generic connection</code> in order to access them in QGIS.</p> <p>Access OGC API Vector Tiles from QGIS</p> <p>Before entering QGIS, access your pygeoapi installation page on the browser and follow these steps.</p> <ul> <li>access the collection page of the tiles dataset: http://localhost:5000/collections/hyderabad</li> <li>navigate to the tiles page by clicking on <code>tiles</code>: http://localhost:5000/collections/hyderabad/tiles</li> <li>click in <code>Tiles metadata in tilejson format</code>: http://localhost:5000/collections/Cycle/hyderabad/WorldCRS84Quad/metadata</li> <li>note the URL in <code>tiles</code>: <code>http://localhost:5000/collections/hyderabad/tiles/WorldCRS84Quad/{tileMatrix}/{tileRow}/{tileCol}?f=mvt</code> and of the values of minZoom and maxZoom</li> </ul> <p>Follow these steps to connect to a service and access vector tiles:</p> <ul> <li>locate the vector tiles service on the left hand side browser panel. Note that you can also use the top menu and navigate to <code>Layer &gt; Add Layer &gt; Vector Tile Layer</code></li> </ul> <p></p> <ul> <li>right-click to bring up the context menu and choose <code>New Generic connection</code></li> <li>fill the required values. For URL, use the URL you noted from the previous step, replacing <code>{tileMatrix}/{tileRow}/{tileCol}</code> with <code>{z}/{x}/{y}</code>.</li> <li>press <code>OK</code> to add the service. At this point, if you are using the browser you should see the collection appearing in the menu, below \"Vector Tiles\"</li> <li>double-click in the collection to add it to the map </li> <li>zoom in to Hyderabad to visualize your dataset</li> </ul> <p> </p>"},{"location":"publishing/ogcapi-tiles/#leafletjs","title":"LeafletJS","text":"<p>LeafletJS is a popular JavaScript library to add interactive maps to websites. LeafletJS does not support OGC API's explicitely, however can interact with OGC API by using the results of the API directly.</p> <p>Add OGC API - Tiles to a website with LeafletJS</p> <ul> <li>copy the HTML below to a file called <code>vector-tiles.html</code>, or locate this file in <code>workshop/exercises/html</code></li> <li>open the file in a web browser</li> </ul> <p>The code uses the LeafletJS library with the leaflet.vectorgrid plugin to display the lakes OGC API - Tiles service on top of an OpenStreetMap base layer.</p> <pre><code>&lt;html&gt;\n&lt;head&gt;&lt;title&gt;OGC API - Tiles exercise&lt;/title&gt;&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=\"map\" style=\"width:100vw;height:100vh;\"&gt;&lt;/div&gt;\n&lt;link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.0.3/dist/leaflet.css\" /&gt;\n&lt;script type=\"text/javascript\" src=\"https://unpkg.com/leaflet@1.3.1/dist/leaflet.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"https://unpkg.com/leaflet.vectorgrid@1.3.0/dist/Leaflet.VectorGrid.bundled.js\"&gt;&lt;/script&gt;\n&lt;script&gt;    \nmap = L.map('map').setView({ lat: 17.425181, lng: 78.5493906 }, 11);\nmap.addLayer(\n    new L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}', {\n    attribution: 'Tiles &amp;copy; Esri &amp;mdash; National Geographic, Esri, DeLorme, NAVTEQ, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, iPC',\n    minZoom: 1,\n    maxZoom: 16,\n    }));\nfunction getColor(val){\n    if (val &lt; 40) {return \"#f2e6c7\"}\n    else if (val &lt; 80) {return \"#8fa37e\"}\n    else if (val &lt; 100) {return \"#f0d17d\"}\n    else if (val &lt; 120) {return  \"#d7ded1\"}\n    else return \"#c2d0d9\";\n}\nvar vectorTileStyling = {\n    greater_hyderabad_municipal_corporation_ward_Boundaries: function(properties) {\n        return ({\n            fill: true,\n            fillColor: getColor(properties.objectid),\n            color: \"#ffffff\",\n            fillOpacity: 1.0,\n            weight: 5,\n            //color: \"#ffffff\",\n            opacity: 1.0,\n        });\n    }\n} \n    var mapVectorTileOptions = {\n        rendererFactory: L.canvas.tile,\n        interactive: true,\n        vectorTileLayerStyles: vectorTileStyling,\n        };\n    var pbfURL='http://localhost:5000/collections/hyderabad/tiles/WorldCRS84Quad/{z}/{x}/{y}?f=mvt';\n    var pbfLayer=L.vectorGrid.protobuf(pbfURL,mapVectorTileOptions).on('click',function(e) {\n        console.log(e.layer);\n    L.DomEvent.stop(e);\n    }).addTo(map); \n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p></p> <p>Tip</p> <p>Try adding a different pygeoapi vector tiles layer by updating the code in <code>workshop/exercises/html/vector-tiles.html</code>.</p> <p>If you want to render the tiles from the Elasticsearch example, you can check out the code from this repository:  <pre><code>git clone -b ogcapi-ws https://github.com/doublebyte1/vtiles-example.git\n</code></pre> </p> <p></p> <p>Tip</p> <p>See the official LeafletJS documentation</p>"},{"location":"publishing/ogcapi-tiles/#openlayers","title":"OpenLayers","text":"<p>OpenLayers is a popular JavaScript library to add interactive maps to websites. OpenLayers natively supports OGC API - Tiles.</p> <p>Tip</p> <p>See the official OpenLayers documentation</p>"},{"location":"publishing/ogcapi-tiles/#summary","title":"Summary","text":"<p>Congratulations! You are now able to publish tiles to pygeoapi.</p>"}]}